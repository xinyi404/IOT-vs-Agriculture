<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Advanced IoT Agriculture Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script>
        // Fallback for D3.js if primary CDN fails
        if (typeof d3 === 'undefined') {
            document.write('<script src="https://unpkg.com/d3@7/dist/d3.min.js"><\/script>');
        }
    </script>
    <style>
        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            margin: 0;
            padding: 30px;
            background: linear-gradient(135deg, #1a3d26 0%, #2d5a3d 30%, #4a6d33 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .navbar {
            position: sticky;
            top: 0;
            margin: 0 -2rem;
            background: transparent;
            box-shadow: none;
            transition: background 0.3s, box-shadow 0.3s;
            z-index: 100;
        }
        .navbar.scrolled {
            background: rgba(240, 248, 240, 0.8);
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .dashboard-header {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            padding: 1rem 2rem;
        }

        .dashboard-description {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px 25px;
            margin: 0 30px 20px;
            border-left: 4px solid #2d5a3d;
            font-size: 14px;
            line-height: 1.5;
            color: #2d5a3d;
        }

        .dashboard-description strong {
            color: #1a3d26;
        }
        
        .dashboard {
            background: rgba(240, 248, 240, 0.5);
            border-radius: 25px;
            width: 90%;
            max-width: 1800px;
            margin: 0 auto;
            padding: 0 2rem 2rem;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
        }
        
        .title-section {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .title {
            font-size: 20px;
            font-weight: 700;
            color: #2d5a3d;
            letter-spacing: -0.5px;
            margin-right: 0.25rem;
        }
        
        .plant-icon {
            font-size: 25px;
            margin-right: 3rem;
        }
        
        .filters {
            display: flex;
            gap: 1rem;
        }
        
        .filter-dropdown {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            padding: 10px 2.5rem 10px 15px;
            border: none;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.9);
            outline: none;
            font-size: 14px;
            font-weight: 500;
            color: #2D5A3D;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: all 0.3s ease;

            background-image:
                url("data:image/svg+xml;charset=UTF-8,<svg xmlns='http://www.w3.org/2000/svg' width='10' height='6'><path fill='%232d5a3d' d='M0 0l5 6 5-6z'/></svg>");
            background-repeat:  no-repeat;
            background-position:calc(100% - 12px) center;
            background-size:    10px 6px;
        }

        .filter-dropdown::-ms-expand {
            display: none;
        }
        
        .filter-dropdown:hover {
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
            transform: translateY(-1px);
        }
        
        .section-headers {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 30px;
            margin-bottom: 20px;
        }
        
        .section-header {
            font-size: 20px;
            font-weight: 700;
            color: #2d5a3d;
            padding: 10px 10px;
            letter-spacing: -0.4px;
        }

        .right-col > .section-header {
            padding: 0;
            margin-bottom: 10px;
        }

        
        /* ============================================================================
           LAYOUT CONTAINERS - Consistent across all breakpoints
           ============================================================================ */
        
        .top-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 2rem;
            margin-bottom: 2rem;
        }
        
        .content-grid.two-col {
            display: grid;
            gap: 2rem;
            grid-template-columns: 1fr 1fr;
            align-items: stretch;
        }

        .left-col, .right-col {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .column-charts {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .column-charts section {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        .column-charts .card-title {
            width: 100%;
            text-align: center;
        }

        .dual-chart {
            display: flex;
            gap: 1rem;
        }

        .dual-chart .card-title{
            min-height: 2.6em;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .dual-chart > div {
            flex: 1;
        }
        
        /* ============================================================================
           CARD STYLES
           ============================================================================ */
        
        .card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
        }
        
        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(0,0,0,0.3);
        }
        
        .card-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #2d5a3d;
            text-align: center;
            font-size: 16px;
            letter-spacing: -0.3px;
        }
        
        .metric-display {
            display: flex;
            align-items: center;
            gap: 30px;
            justify-content: center;
            margin-top: 10px;
        }
        
        .metric-item {
            text-align: center;
        }
        
        .metric-value {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 8px;
            color: #2d5a3d;
        }
        
        .metric-label {
            font-size: 12px;
            color: #b1b1b1;
            font-weight: 500;
        }
        
        .metric-circle {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 15px;
            font-size: 16px;
            font-weight: 700;
            color: #ffffffb7;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .iot-circle {
            background: linear-gradient(135deg, #8ed3e4, #0599fc);
        }
        
        .traditional-circle {
            background: linear-gradient(135deg, #7EA25B, #384b3d);
        }
        
        .card .chart-area {
            display: flex;
            flex-direction: column;
            flex: 1 1 auto;
        }

        .card .insights-panel {
            margin-top: auto;
        }
        
        .chart-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .bar-default {
            fill: #4a7c59;
        }
        
        .bar-default:hover {
            fill: #2d5a3d;
        }
        
        .axis {
            font-size: 12px;
        }
        
        .pie-slice {
            stroke: white;
            stroke-width: 2;
        }
        
        /* ============================================================================
           RESPONSIVE DESIGN
           ============================================================================ */

        /* Tablets and smaller */
        @media (max-width: 1024px) {
            .content-grid.two-col {
                grid-template-columns: 1fr;
                gap: 1.5rem;
            }

            .dual-chart {
                flex-direction: column;
                gap: 1rem;
            }

            .dashboard-header {
                flex-direction: column;
                gap: 1rem;
                text-align: center;
            }

            .section-header-wrapper {
                flex-direction: column;
                gap: 1rem;
                align-items: center;
            }
        }

        /* Mobile */
        @media (max-width: 768px) {
            body {
                padding: 15px;
            }

            .dashboard {
                padding: 0 1rem 1rem;
            }

            .dashboard-header {
                padding: 1rem;
            }

            .card {
                padding: 16px;
                border-radius: 16px;
            }

            .top-row {
                grid-template-columns: 1fr;
                gap: 1.5rem;
            }

            .metric-display {
                flex-direction: column;
                gap: 1rem;
            }

            .metric-circle {
                width: 60px;
                height: 60px;
                font-size: 12px;
            }

            .title {
                font-size: 16px;
            }

            .section-header {
                font-size: 16px;
            }

            .dashboard-description {
                margin: 0 15px 15px;
                padding: 12px 18px;
                font-size: 13px;
            }
        }

        /* Small mobile */
        @media (max-width: 480px) {
            body {
                padding: 10px;
            }

            .dashboard {
                padding: 0 0.75rem 0.75rem;
            }

            .dashboard-header {
                padding: 0.75rem;
            }

            .card {
                padding: 12px;
                border-radius: 12px;
            }

            .title {
                font-size: 14px;
            }

            .metric-circle {
                width: 50px;
                height: 50px;
                font-size: 11px;
            }

            .filter-dropdown {
                min-width: 120px;
                font-size: 12px;
            }

            .dashboard-description {
                margin: 0 10px 12px;
                padding: 10px 15px;
                font-size: 12px;
                border-left-width: 3px;
            }
        }

        /* Responsive modal */
        @media (max-width: 768px) {
            .chart-modal-content {
                max-width: 95vw;
                max-height: 95vh;
                padding: 20px;
            }

            .chart-modal-title {
                font-size: 18px;
            }

            .chart-modal-close {
                width: 35px;
                height: 35px;
                font-size: 16px;
            }
        }
        
        /* Expandable Insight Panel Styles */
        .insights-panel {
            background: rgba(45, 90, 61, 0.95);
            color: white;
            border-radius: 12px;
            margin-top: 15px;
            border: 1px solid rgba(255,255,255,0.2);
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .insights-toggle {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            padding: 12px 20px;
            width: 100%;
            text-align: left;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: background-color 0.2s ease;
        }
        
        .insights-toggle:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        
        .insights-toggle .toggle-icon {
            transition: transform 0.3s ease;
            font-size: 12px;
        }
        
        .insights-toggle.active .toggle-icon {
            transform: rotate(180deg);
        }
        
        .insights-content {
            padding: 0 20px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }
        
        .insights-content.expanded {
            max-height: none;
            height: auto;
            padding: 18px 20px;
            overflow: visible;
        }
        
        .insights-content h4 {
            margin: 0 0 10px 0;
            font-size: 16px;
            font-weight: 700;
            color: #90EE90;
        }
        
        .insights-content h4:not(:first-child) {
            margin-top: 20px;
        }
        
        .insights-content p {
            margin: 0 0 15px 0;
            font-weight: 500;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .insights-content p:last-child {
            margin-bottom: 0;
        }

        .section-header-wrapper {
            display: flex;
            align-items: center;
            gap: 2rem;
        }

        /* Legend CSS */
        .legend-box {
            display: flex;
            align-items: center;
            gap: 0.5rem; 
            background: rgba(255, 255, 255, 0.9);
            padding: 0.4rem 1rem;
            border-radius: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .dot {
            width: 12px;
            height: 12px;
            border: 2px solid #333;
            border-radius: 50%;
        }

        .legend-box span:not(.dot) {
            font-size: 12px;
            font-weight: bold;
            color: #2d5a3d;
        }

        .dot.iot + span {
            margin-right: 1rem;
        }

        .dot.iot { background: #8ed3e4; }
        .dot.traditional { background: #7EA25B; }

        
        .filter-dropdown:focus,
        .insights-toggle:focus {
            outline: 2px solid #2d5a3d;
            outline-offset: 2px;
        }

        .insights-toggle,
        .filter-dropdown,
        .legend-box {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Improve chart container responsiveness */
        .chart-content svg {
            max-width: 100%;
            height: auto;
        }

        /* Force center ALL Biomass Allocation charts */
        .column-charts {
            text-align: center;
        }

        .column-charts section {
            text-align: center;
        }

        .column-charts #biomassChart,
        .column-charts #scatterChart, 
        .column-charts #rootShootChart {
            text-align: center !important;
            display: block !important;
            width: 100% !important;
        }

        .column-charts #biomassChart svg,
        .column-charts #scatterChart svg, 
        .column-charts #rootShootChart svg {
            margin: 0 auto !important;
            display: block !important;
        }

        /* Touch-friendly targets */
        @media (max-width: 768px) {
            .insights-toggle, .filter-dropdown {
                min-height: 44px;
            }
        }

        /* ============================================================================
           TOOLTIP STYLES
           ============================================================================ */
        
        .chart-tooltip {
            position: absolute;
            background: rgba(45, 90, 61, 0.95);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 1000;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .chart-tooltip.visible {
            opacity: 1;
        }

        .tooltip-title {
            font-weight: 700;
            margin-bottom: 5px;
            color: #90EE90;
            font-size: 15px;
        }

        .tooltip-content {
            font-size: 13px;
            line-height: 1.4;
        }

        /* ============================================================================
           EXPANDABLE CHART MODAL
           ============================================================================ */

        .chart-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
            box-sizing: border-box;
        }

        .chart-modal.active {
            display: flex;
        }

        .chart-modal-content {
            background: rgba(255, 255, 255, 0.98);
            border-radius: 20px;
            padding: 30px;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
            position: relative;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .chart-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #2d5a3d;
            padding-bottom: 15px;
        }

        .chart-modal-title {
            font-size: 24px;
            font-weight: 700;
            color: #2d5a3d;
            margin: 0;
        }

        .chart-modal-close {
            background: #2d5a3d;
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .chart-modal-close:hover {
            background: #1a3d26;
            transform: scale(1.1);
        }

        .chart-modal-body {
            text-align: center;
        }

        .chart-modal-body svg {
            max-width: 100%;
            height: auto;
        }

        /* Expandable card cursor */
        .expand-wrapper {
            position:relative;
        }

        .expand-btn{
            position:absolute;
            right: 0.5px;
            width:30px;
            height:30px;
            border:none;
            border-radius:50%;
            background:rgba(255,255,255,0.85);
            box-shadow:0 2px 6px rgba(0,0,0,.15);
            display:flex;
            align-items:center;
            justify-content:center;
            cursor:pointer;
            opacity:0; /* start invisible */
            pointer-events:none;
            transition:opacity .25s, transform .25s;
        }

        .expand-btn::before {
            content:"🔍";
            font-size:16px;
        }

        .card:hover .expand-btn{
            opacity:1;
            pointer-events:auto;
        }

        .card:hover .expand-btn:hover{
            transform:scale(1.12);
        }
    </style>
</head>
<body>
    <div class="dashboard">
        <nav class="navbar">
            <div class="dashboard-header">
              <h1 class="title">Advanced IoT Agriculture Dashboard</h1>
              <span class="plant-icon">🌱</span>
              <div class="filters">
                <select class="filter-dropdown" id="greenhouseFilter">
                    <option value="all">All Greenhouse Type</option>
                    <option value="traditional">Traditional</option>
                    <option value="iot">IoT</option>
                </select>
                <select class="filter-dropdown" id="batchFilter">
                    <option value="all">All Batches</option>
                    <option value="R1">R1</option>
                    <option value="R2">R2</option>
                    <option value="R3">R3</option>
                </select>
              </div>
            </div>
        </nav>

        <div class="dashboard-description">
            <strong>Research Dataset:</strong> Comprehensive data gathered in 2023–2024 from Tikrit University's Agriculture Lab to develop predictive models and conduct exploratory analyses of key growth indicators under varying greenhouse conditions. 
            <strong>Agricultural POC:</strong> Serves as a proof-of-concept for farmers in the agriculture sector to analyze plant conditions and compare how IoT methods and traditional greenhouse approaches differ.
        </div>
    
        <main class="dashboard-content">
            <div class="content-grid two-col">
                <div class="left-col">
                    <!-- Top Row -->
                    <section class="top-row">
                        <div class="card chart-area">
                            <div class="chart-click-target expand-wrapper"
                                 onclick="openChartModal('Class Proportion Summary', 'classPieChart', createExpandedPieChart)">
                                 <button class="expand-btn" aria-label="Expand Chart"></button>
                                <div class="card-title">Class Proportion Summary</div>
                                <div id="classPieChart"></div>
                            </div>
                            <div class="insights-panel">
                                <button class="insights-toggle">
                                    <span>💡 Chart Insights</span>
                                    <span class="toggle-icon">▼</span>
                                </button>
                                <div class="insights-content">
                                    <h4>📊 Data Distribution</h4>
                                    <p>Shows the proportion of Traditional vs IoT greenhouse systems in your dataset. This helps understand the balance of your experimental design and data representation.</p>
                                </div>
                            </div>
                        </div>
                        <div class="card chart-area">
                            <div class="chart-click-target expand-wrapper"
                                 onclick="openChartModal('Average Shoot Dry Matter %', 'avgShootDryMatter', createExpandedMetricDisplay)">
                                 <button class="expand-btn" aria-label="Expand Chart"></button>
                            
                                <div class="card-title">Average Shoot Dry Matter %</div>
                                <div class="metric-display" id="avgShootDryMatter">
                                    <div style="display: flex; gap: 60px; align-items: center; justify-content: center; margin-bottom: 10px; margin-top: 10px;">
                                        <div class="metric-item">
                                            <div class="metric-circle iot-circle"></div>
                                            <div class="metric-value" id="iotValue">...</div>
                                            <div class="metric-label">IoT</div>
                                        </div>
                                        <div class="metric-item">
                                            <div class="metric-circle traditional-circle"></div>
                                            <div class="metric-value" id="traditionalValue">...</div>
                                            <div class="metric-label">Traditional</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="insights-panel">
                                <button class="insights-toggle">
                                    <span>💡 Chart Insights</span>
                                    <span class="toggle-icon">▼</span>
                                </button>
                                <div class="insights-content">
                                    <h4>🌱 Biomass Efficiency</h4>
                                    <p>Compares average shoot dry weight between IoT and Traditional systems. Higher values indicate better biomass production efficiency. IoT systems typically show improved growth performance.</p>
                                </div>
                            </div>
                        </div>
                    </section>
    
                    <!-- PHR Header -->
                    <div class="section-header-wrapper">
                        <div class="section-header">Plant Height Rate Insights</div>
                    
                        <div class="legend-box">
                        <span class="dot iot"></span><span>IoT</span>
                        <span class="dot traditional"></span><span>Traditional</span>
                        </div>
                    </div>
                    
    
                    <!-- Section 1: Plant Height Rate Insights -->
                    <div style="margin-bottom: 10px;">
                        <div class="card chart-area">
                            <div class="chart-click-target expand-wrapper"
                                 onclick="openChartModal('Plant Height Rate Insights', 'plantHeightInsights', createExpandedDualChart)">
                                <button class="expand-btn" aria-label="Expand Chart"></button>
                                <div class="dual-chart">
                                    <div>
                                        <div class="card-title">Plant Height Rate by Batch</div>
                                        <div id="heightByBatchChart"></div>
                                    </div>
                                    <div>
                                        <div class="card-title">Plant Height Rate vs Avg Number of Leaves</div>
                                        <div id="leavesChart"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="insights-panel">
                                <button class="insights-toggle">
                                    <span>💡 Chart Insights</span>
                                    <span class="toggle-icon">▼</span>
                                </button>
                                <div class="insights-content">
                                    <h4>📏 Plant Height Rate by Batch</h4>
                                    <p>Tracks plant height growth rate across different experimental batches (R1, R2, R3). Reveals which batches and greenhouse types achieve optimal vertical growth, indicating overall plant health and vigor.</p>
                                    
    
                                    <h4>🍃 Plant Height Rate vs Avg Number of Leaves</h4>
                                    <p>Analyzes how leaf quantity affects plant height growth. Shows the relationship between foliage development and vertical growth rates. Error bars indicate growth variability within each leaf count category.</p>
                                </div>
                            </div>
                        </div>
                    </div>
    
                    <!-- Growth Header -->
                     <div class="section-header-wrapper">
                        <div class="section-header">Growth Dynamics & Variability</div>
                    
                        <div class="legend-box">
                        <span class="dot iot"></span><span>IoT</span>
                        <span class="dot traditional"></span><span>Traditional</span>
                        </div>
                    </div>

                    <!-- Section 2: Growth Dynamics & Variability -->
                    <div style="margin-bottom: 10px;">
                        <div class="card chart-area">
                            <div class="chart-click-target expand-wrapper"
                                 onclick="openChartModal('Growth Dynamics & Variability', 'growthDynamics', createExpandedDualChart)">
                                <button class="expand-btn" aria-label="Expand Chart"></button>
                                <div class="dual-chart">
                                    <div>
                                        <div class="card-title">Growth Distribution (PHR/ACHP/ARL)</div>
                                        <div id="growthDynamicsChart"></div>
                                    </div>
                                    <div>
                                        <div class="card-title">Dry-Matter Violin Comparison</div>
                                        <div id="violinPlotChart"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="insights-panel">
                                <button class="insights-toggle">
                                    <span>💡 Chart Insights</span>
                                    <span class="toggle-icon">▼</span>
                                </button>
                                <div class="insights-content">
                                    <h4>📈 Growth Distribution (PHR/ACHP/ARL)</h4>
                                    <p>Box plots show distribution patterns of key growth metrics including Plant Height Rate, Average Chlorophyll (ACHP), and Average Root Length (ARL). Reveals data spread, outliers, and median values across Traditional vs IoT greenhouse systems.</p>
                                    
                                    <h4>🎻 Dry-Matter Violin Comparison</h4>
                                    <p>Violin plots reveal the shape and density distributions of dry matter values (PDMVG and PDMRG). Shows data concentration areas and helps identify optimal growing conditions by comparing the distribution patterns between different plant dry matter categories.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="right-col">
                    <!-- Biomass Header -->
                    <div class="section-header">Biomass Allocation</div>
                                
                    <!-- Section 3: Biomass Allocation -->
                    <div class="card chart-area">
                        <div class="chart-click-target expand-wrapper"
                             onclick="openChartModal('Biomass Allocation', 'biomassAllocation', createExpandedBiomassCharts)">
                            <button class="expand-btn" aria-label="Expand Chart"></button>
                            <div class="column-charts">
                                <section>
                                <div class="card-title">Vegetative Biomass Comparison</div>
                                <div id="biomassChart"></div>
                                </section>
                                <section>
                                <div class="card-title">Root Weight vs Root Diameter</div>
                                <div id="scatterChart"></div>
                                </section>
                                <section>
                                <div class="card-title">Root-to-Shoot Ratio by Greenhouse</div>
                                <div id="rootShootChart"></div>
                                </section>
                            </div>
                        </div>
                        <div class="insights-panel">
                            <button class="insights-toggle">
                                <span>💡 Chart Insights</span>
                                <span class="toggle-icon">▼</span>
                            </button>
                            <div class="insights-content">
                                <h4>🌿 Vegetative Biomass Comparison</h4>
                                <p>Compares wet vs dry vegetative biomass across batches. Shows how efficiently plants convert water uptake into solid growth. Higher ADWV (dry weight) indicates better resource utilization and plant productivity. User may compare IoT and Traditional, or drill down to different batches of that particular greenhouse type.</p>
                                
                                <h4>🌱 Root Weight vs Root Diameter</h4>
                                <p>Scatter plot analyzing the relationship between root wet weight (AWWR) and root diameter (ARD). Shows root morphology patterns and helps identify how root thickness correlates with root mass across different greenhouse systems. The trendline reveals growth efficiency patterns.</p>
                                
                                <h4>⚖️ Root-to-Shoot Ratio by Greenhouse</h4>
                                <p>Box plot comparing root-to-shoot biomass ratios between greenhouse types. Lower ratios indicate more energy invested in above-ground growth, while higher ratios show stronger root development. Reveals system efficiency differences.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Chart Expansion Modal -->
    <div id="chartModal" class="chart-modal">
        <div class="chart-modal-content">
            <div class="chart-modal-header">
                <h2 id="chartModalTitle" class="chart-modal-title"></h2>
                <button class="chart-modal-close" onclick="closeChartModal()">&times;</button>
            </div>
            <div id="chartModalBody" class="chart-modal-body">
            </div>
        </div>
    </div>

    <!-- Chart Tooltip -->
    <div id="chartTooltip" class="chart-tooltip">
        <div id="tooltipContent"></div>
    </div>
    

    <script>
        // Nav bar scroll action
        const nav = document.querySelector('.navbar');
        window.addEventListener('scroll', () => {
            if (window.scrollY > 0) {
            nav.classList.add('scrolled');
            } else {
            nav.classList.remove('scrolled');
            }
        });

        // ============================================================================
        // D3.js VERIFICATION & LOADING
        // ============================================================================
        
        // Wait for D3 to be available
        function waitForD3(callback, attempts = 0) {
            if (typeof d3 !== 'undefined') {
                console.log('D3.js loaded successfully');
                callback();
            } else if (attempts < 50) { // Wait up to 5 seconds
                setTimeout(() => waitForD3(callback, attempts + 1), 100);
            } else {
                console.error('Failed to load D3.js after multiple attempts');
                showErrorMessage('Failed to load required libraries. Please refresh the page.');
            }
        }

        // ============================================================================
        // GLOBAL VARIABLES & CONFIGURATION
        // ============================================================================
        
        let data = [];
        let filteredData = [];
        
        
        // Chart configuration constants
        const CHART_CONFIG = {
            colors: {
                iot: '#87CEEB',
                traditional: '#7EA25B',
                r1: '#FF8C00',
                r2: '#8A2BE2',
                r3: '#DC143C',
            },
            animations: {
                duration: {
                    fast: 300,
                    medium: 600,
                    slow: 1000,
                    elastic: 1500
                },
                easing: {
                    elastic: d3.easeElasticOut.amplitude(1).period(0.4),
                    back: d3.easeBackOut,
                    quad: d3.easeQuadOut,
                    bounce: d3.easeBounceOut
                }
            },
            margins: {
                small: { top: 20, right: 20, bottom: 40, left: 50 },
                medium: { top: 30, right: 30, bottom: 60, left: 60 },
                large: { top: 30, right: 30, bottom: 80, left: 60 }
            }
        };

        // Responsive utilities
        function getResponsiveConfig() {
            const width = window.innerWidth;
            if (width <= 480) {
                return {
                    margins: { top: 20, right: 15, bottom: 50, left: 45 },
                    fontSize: { axis: '8px', label: '10px', title: '12px' },
                    chartHeight: 200,
                    animationDuration: 400
                };
            } else if (width <= 768) {
                return {
                    margins: { top: 25, right: 20, bottom: 60, left: 50 },
                    fontSize: { axis: '9px', label: '11px', title: '13px' },
                    chartHeight: 250,
                    animationDuration: 600
                };
            } else if (width <= 992) {
                return {
                    margins: { top: 30, right: 25, bottom: 70, left: 55 },
                    fontSize: { axis: '10px', label: '12px', title: '14px' },
                    chartHeight: 280,
                    animationDuration: 800
                };
            } else {
                return {
                    margins: { top: 40, right: 40, bottom: 80, left: 70 },
                    fontSize: { axis: '12px', label: '14px', title: '16px' },
                    chartHeight: 300,
                    animationDuration: 1000
                };
            }
        }
  
        const greenhouseColor = d3.scaleOrdinal()
            .domain(['IoT','Traditional'])
            .range([ CHART_CONFIG.colors.iot, CHART_CONFIG.colors.traditional ]);

        const batchColor = d3.scaleOrdinal()
            .domain(['R1','R2','R3'])
            .range([ CHART_CONFIG.colors.r1,  CHART_CONFIG.colors.r2, CHART_CONFIG.colors.r3 ]);

        // ============================================================================
        // DATA LOADING & PROCESSING
        // ============================================================================
        
        /**
         * Load and process CSV data
         * Transforms raw CSV data into a clean, standardized format
         */
        async function loadData() {
            try {
                const csvData = await d3.csv("Advanced_IoT_Dataset.csv");
                data = processRawData(csvData);
                filteredData = [...data]; // Initialize filtered data
                setupEventListeners();
                createAllVisualizations();
            } catch (error) {
                console.error('Error loading data:', error);
                showErrorMessage('Failed to load data. Please check your connection.');
            }
        }
        
        /**
         * Process raw CSV data into clean format
        **/
        function processRawData(csvData) {
            return csvData.map(d => ({
                // Batch information
                random: d.Random,
                class: d.Class,
                greenhouse: d.Class.startsWith('T') ? 'Traditional' : 'IoT',
                
                // Growth metrics
                phr: parseFloat(d[' Plant height rate (PHR)']) || 0,
                achp: parseFloat(d[' Average  of chlorophyll in the plant (ACHP)']) || 0,
                arl: parseFloat(d['Average root length (ARL)']) || 0,
                
                // Biomass metrics
                awwgv: parseFloat(d['Average wet weight of the growth vegetative (AWWGV)']) || 0,
                adwv: parseFloat(d[' Average dry weight of vegetative plants (ADWV)']) || 0,
                adwr: parseFloat(d[' Average dry weight of the root (ADWR)']) || 0,
                awwr: parseFloat(d['Average wet weight of the root (AWWR)']) || 0,
                
                // Plant characteristics
                alap: parseFloat(d['Average leaf area of the plant (ALAP)']) || 0,
                anpl: parseFloat(d['Average number of plant leaves (ANPL)']) || 0,
                ard: parseFloat(d['Average root diameter (ARD)']) || 0,
                
                // Dry matter percentages
                pdmvg: parseFloat(d[' Percentage of dry matter for vegetative growth (PDMVG)']) || 0,
                pdmrg: parseFloat(d['Percentage of dry matter for root growth (PDMRG)']) || 0
            }));
        }
        
        // ============================================================================
        // FILTER & EVENT HANDLING
        // ============================================================================
        
        /**
         * Setup event listeners for filters and interactions
         */
        function setupEventListeners() {
            const greenhouseFilter = document.getElementById('greenhouseFilter');
            const batchFilter = document.getElementById('batchFilter');
            
            if (greenhouseFilter) greenhouseFilter.addEventListener('change', applyFilters);
            if (batchFilter) batchFilter.addEventListener('change', applyFilters);
            
            // Initialize expandable insight panels
            initializeInsightPanels();
        }
        
        /**
         * Apply filters and refresh visualizations
         */
        function applyFilters() {
            const filters = getFilterValues();
            
            showLoadingState();
            filteredData = filterData(data, filters);
            
            setTimeout(() => {
                clearAllCharts();
                createAllVisualizations();
                hideLoadingState();
            }, 100);
        }
        
        /**
         * Get current filter values from UI
         */
        function getFilterValues() {
            return {
                greenhouse: document.getElementById('greenhouseFilter')?.value || 'all',
                batch: document.getElementById('batchFilter')?.value || 'all'
            };
        }
        
        /**
         * Filter data based on current filter settings
         * @param {Array} dataToFilter - Source data array
         * @param {Object} filters - Filter configuration
         * @returns {Array} Filtered data array
         */
        function filterData(dataToFilter, filters) {
            return dataToFilter.filter(record => {
                // Apply greenhouse filter
                if (filters.greenhouse !== 'all') {
                    const selectedGreenhouse = filters.greenhouse === 'iot' ? 'IoT' : 'Traditional';
                    if (record.greenhouse !== selectedGreenhouse) return false;
                }
                
                // Apply batch filter
                if (filters.batch !== 'all') {
                    if (record.random !== filters.batch) return false;
                }
                
                return true;
            });
        }
        
        /**
         * Show loading state during chart updates
         */
        function showLoadingState() {
            const filters = ['greenhouseFilter', 'batchFilter'];
            filters.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.disabled = true;
            });
        }
        
        /**
         * Hide loading state after chart updates
         */
        function hideLoadingState() {
            const filters = ['greenhouseFilter', 'batchFilter'];
            filters.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.disabled = false;
            });
        }
        
        /**
         * Clear all chart containers
         */
        function clearAllCharts() {
            const chartIds = [
                "#classPieChart", "#heightByBatchChart", "#growthDynamicsChart",
                "#violinPlotChart", "#biomassChart", "#scatterChart", 
                "#leavesChart", "#rootShootChart"
            ];
            
            chartIds.forEach(id => {
                d3.select(id).selectAll("*").remove();
            });
        }
        
        /**
         * Create all visualizations
         */
        function createAllVisualizations() {
            try {
                createClassPieChart();
                updateAverageDryMatter();
                createHeightByBatchChart();
                createGrowthDynamicsChart();
                createViolinPlotChart();
                createBiomassChart();
                createScatterChart();
                createLeavesChart();
                createRootShootChart();
            } catch (error) {
                console.error('Error creating visualizations:', error);
                showErrorMessage('Error creating charts. Please refresh the page.');
            }
        }
        
        /**
         * Show error message to user
         * @param {string} message - Error message to display
         */
        function showErrorMessage(message) {
            console.error(message);
            
            // Create error message display
            const dashboard = document.querySelector('.dashboard');
            if (dashboard) {
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #f44336;
                    color: white;
                    padding: 15px 20px;
                    border-radius: 8px;
                    font-weight: bold;
                    z-index: 10000;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                `;
                errorDiv.textContent = message;
                
                document.body.appendChild(errorDiv);
                
                // Auto-hide after 5 seconds
                setTimeout(() => {
                    if (errorDiv && errorDiv.parentNode) {
                        errorDiv.parentNode.removeChild(errorDiv);
                    }
                }, 5000);
            }
        }
        
        // ============================================================================
        // TOOLTIP FUNCTIONALITY
        // ============================================================================

        /**
         * Show tooltip with custom content
         * @param {Event} event - Mouse event for positioning
         * @param {string} content - HTML content for tooltip
         */
        function showTooltip(event, content) {
            const tooltip = document.getElementById('chartTooltip');
            const tooltipContent = document.getElementById('tooltipContent');
            
            tooltipContent.innerHTML = content;
            tooltip.classList.add('visible');
            
            // Position tooltip relative to mouse
            const rect = tooltip.getBoundingClientRect();
            const x = event.pageX + 15;
            const y = event.pageY - rect.height - 10;
            
            tooltip.style.left = x + 'px';
            tooltip.style.top = y + 'px';
        }

        /**
         * Hide tooltip
         */
        function hideTooltip() {
            const tooltip = document.getElementById('chartTooltip');
            tooltip.classList.remove('visible');
        }

        // ============================================================================
        // CHART CREATION FUNCTIONS
        // ============================================================================
        
        /**
         * Create pie chart showing class proportions
         */
        function createClassPieChart() {
            const config = {
                width: 200,
                height: 180,
                radius: 60,
                center: { x: 100, y: 90 }
            };
            
            const svg = createBaseSVG("#classPieChart", config.width, config.height);
            const g = svg.append("g").attr("transform", `translate(${config.center.x},${config.center.y})`);
            
            // Prepare data
            const pieData = preparePieData(filteredData);
            const { pie, arc } = createPieGenerators(config.radius);
            const colorScale = createColorScale(['Iot', 'Traditional'], [CHART_CONFIG.colors.traditional, CHART_CONFIG.colors.iot]);
            
            // animate pie slices
            createAnimatedPieSlices(g, pie(pieData), arc, colorScale);
            
            // Add labels
            createPieLabels(g, pie(pieData), arc, filteredData.length);
        }
        
        /**
         * Create base SVG element with responsive sizing
         */
        function createBaseSVG(selector, width, height) {
            return d3.select(selector)
                .append("svg")
                .attr("width", "100%")
                .attr("height", height)
                .attr("viewBox", `0 0 ${width} ${height}`);
        }
        
        /**
         * Prepare data for pie chart
         */
        function preparePieData(data) {
            const classData = d3.rollup(data, v => v.length, d => d.greenhouse);
            return Array.from(classData, ([key, value]) => ({ greenhouse: key, count: value }));
        }
        
        /**
         * Create pie and arc generators
         */
        function createPieGenerators(radius) {
            const pie = d3.pie()
                .value(d => d.count)
                .startAngle(0)
                .endAngle(2 * Math.PI);
                
            const arc = d3.arc()
                .innerRadius(0)
                .outerRadius(radius);
                
            return { pie, arc };
        }
        
        /**
         * Create color scale for charts
         */
        function createColorScale(domain, range) {
            return d3.scaleOrdinal().domain(domain).range(range);
        }
        
        /**
         * Create animated pie slices with tooltip functionality
         */
        function createAnimatedPieSlices(container, data, arc, colorScale) {
            const slices = container.selectAll('.pie-slice')
                .data(data)
                .enter()
                .append('path')
                .attr('class', 'pie-slice')
                .attr('fill', d => colorScale(d.data.greenhouse))
                .style('opacity', 0)
                .style('cursor', 'pointer');
                
            // Add tooltip functionality
            slices
                .on('mouseover', function(event, d) {
                    // Highlight the slice
                    d3.select(this)
                        .style('opacity', 0.8)
                        .style('stroke', '#fff')
                        .style('stroke-width', '3px');

                    const flipped = d.data.greenhouse === 'IoT'
                                    ? 'Traditional'
                                    : 'IoT';
                    
                    // Show tooltip with record count
                    const percentage = Math.round(d.data.count / filteredData.length * 100);
                    const content = `
                        <div class="tooltip-title">${flipped} Greenhouse</div>
                        <div class="tooltip-content">
                            Records: <strong>${d.data.count}</strong><br/>
                            Percentage: <strong>${percentage}%</strong>
                        </div>
                    `;
                    showTooltip(event, content);
                })
                .on('mouseout', function(event, d) {
                    // Remove highlight
                    d3.select(this)
                        .style('opacity', 1)
                        .style('stroke', 'white')
                        .style('stroke-width', '2px');
                    
                    // Hide tooltip
                    hideTooltip();
                });
                
            slices.transition()
                .duration(CHART_CONFIG.animations.duration.slow)
                .delay((d, i) => i * 200)
                .ease(CHART_CONFIG.animations.easing.back)
                .style('opacity', 1)
                .attrTween('d', function(d) {
                    const interpolate = d3.interpolate({ startAngle: 0, endAngle: 0 }, d);
                    return t => arc(interpolate(t));
                });
        }
        
        /**
         * Create pie chart labels
         */
        function createPieLabels(container, data, arc, totalCount) {
            const labels = container.selectAll('.pie-label')
                .data(data)
                .enter()
                .append('text')
                .attr('class', 'pie-label')
                .attr('transform', d => `translate(${arc.centroid(d)})`)
                .attr('text-anchor', 'middle')
                .attr('font-size', '14px')
                .attr('font-weight', 'bold')
                .attr('fill', '#fff')
                .style('opacity', 0)
                .text(d => `${Math.round(d.data.count / totalCount * 100)}%`);
                
            labels.transition()
                .duration(CHART_CONFIG.animations.duration.medium)
                .delay(1000)
                .ease(CHART_CONFIG.animations.easing.quad)
                .style('opacity', 1);
        }
        
        // ============================================================================
        // UTILITY FUNCTIONS
        // ============================================================================
        
        /**
         * Calculate averages by greenhouse type for a given metric
         * @param {Array} data - Dataset to analyze
         * @param {string} metric - Metric property name
         * @returns {Object} Averages by greenhouse type
         */
        function calculateAveragesByGreenhouse(data, metric) {
            const groupedData = d3.rollup(data, v => d3.mean(v, d => d[metric]), d => d.greenhouse);
            return {
                iot: groupedData.get('IoT') || 0,
                traditional: groupedData.get('Traditional') || 0
            };
        }
        
        /**
         * Calculate percentages for metric display
         * @param {number} iotValue - IoT value
         * @param {number} traditionalValue - Traditional value
         * @returns {Object} Percentage values
         */
        function calculatePercentages(iotValue, traditionalValue) {
            const total = iotValue + traditionalValue;
            return {
                iot: total > 0 ? Math.round((iotValue / total) * 100) : 0,
                traditional: total > 0 ? Math.round((traditionalValue / total) * 100) : 0
            };
        }
        
        /**
         * Animate text content with scale effect
         * @param {HTMLElement} element - Target element
         * @param {string} newText - New text content
         */
        function animateText(element, newText) {
            if (!element) return;
            
            element.style.transition = 'transform 0.3s ease';
            element.style.transform = 'scale(0.8)';
            
            setTimeout(() => {
                element.textContent = newText;
                element.style.transform = 'scale(1)';
            }, 150);
        }
        
        /**
         * Animate value update with fade effect
         * @param {string} elementId - Element ID
         * @param {string} newValue - New value to display
         */
        function animateValue(elementId, newValue) {
            const element = document.getElementById(elementId);
            if (!element) return;
            
            element.style.opacity = '0';
            
            setTimeout(() => {
                element.textContent = newValue;
                element.style.transition = 'opacity 0.3s ease';
                element.style.opacity = '1';
            }, 150);
        }
        
        // ============================================================================
        // METRIC UPDATE FUNCTIONS
        // ============================================================================
        
        /**
         * Update average dry matter metrics and display
         */
         function updateAverageDryMatter() {
            const { batch } = getFilterValues();   // "all" | "R1" | "R2" | "R3"

            // 1) pick the slice we want to compare
            let subset = data;                     // note: use the full dataset, not filteredData
            if (batch !== 'all') {
                subset = data.filter(d => d.random === batch);
            }

            // 2) roll up average PDMVG by greenhouse
            const grouped = d3.rollup(
                subset,
                v => d3.mean(v, d => d.pdmvg),
                d => d.greenhouse      // "IoT" or "Traditional"
            );
            const iot         = grouped.get('IoT')         || 0;
            const traditional = grouped.get('Traditional') || 0;

            // 3) compute the two‐way % split
            const total = iot + traditional;
            const percentages = {
                iot:       total ? Math.round(iot         / total * 100) : 0,
                traditional: total ? Math.round(traditional / total * 100) : 0
            };

            // 4) hand off to your existing display helpers
            updateCirclePercentages(percentages);
            updateMetricValues({ iot, traditional });
            }

        
        /**
         * Update circle percentage displays
         * @param {Object} percentages - Percentage values for each type
         */
        function updateCirclePercentages(percentages) {
            const circles = {
                iot: document.querySelector('.iot-circle'),
                traditional: document.querySelector('.traditional-circle')
            };
            
            if (circles.iot) animateText(circles.iot, `${percentages.iot}%`);
            if (circles.traditional) animateText(circles.traditional, `${percentages.traditional}%`);
        }
        
        /**
         * Update metric value displays
         * @param {Object} averages - Average values for each type
         */
        function updateMetricValues(averages) {
            animateValue('iotValue', `${averages.iot.toFixed(3)} g`);
            animateValue('traditionalValue', `${averages.traditional.toFixed(3)} g`);
        }
        
        function createPlantHeightChart() {
            const svg = d3.select("#plantHeightChart")
                .append("svg")
                .attr("height", 300)
                .attr("viewBox", "0 0 300 300");
                
            const margin = { top: 40, right: 40, bottom: 80, left: 70 };
            const width = 300 - margin.left - margin.right;
            const height = 300 - margin.top - margin.bottom;
            
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
                
            // Group data by greenhouse type
            const groupedData = d3.rollup(filteredData, 
                v => d3.mean(v, d => d.phr), 
                d => d.greenhouse
            );
            
            const chartData = Array.from(groupedData, ([key, value]) => ({greenhouse: key, avgHeight: value}));
            
            const x = d3.scaleBand()
                .domain(chartData.map(d => d.greenhouse))
                .range([0, width])
                .padding(0.1);
                
            const y = d3.scaleLinear()
                .domain([0, d3.max(chartData, d => d.avgHeight)])
                .range([height, 0]);
                
            g.selectAll(".bar-default")
                .data(chartData)
                .enter().append("rect")
                .attr("class", "bar-default")
                .attr("x", d => x(d.greenhouse))
                .attr("width", x.bandwidth())
                .attr("y", d => y(d.avgHeight))
                .attr("height", d => height - y(d.avgHeight));
                
            g.append("g")
                .attr("class", "axis")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x));
                
            g.append("g")
                .attr("class", "axis")
                .call(d3.axisLeft(y));
        }
        
        function createHeightByBatchChart() {
            const responsiveConfig = getResponsiveConfig();
            const chartHeight = responsiveConfig.chartHeight;
            
            const svg = d3.select("#heightByBatchChart")
                .append("svg")
                .attr("width", "100%")
                .attr("height", chartHeight)
                .attr("viewBox", `0 0 300 ${chartHeight}`);
                
            const margin = responsiveConfig.margins;
            const width = 300 - margin.left - margin.right;
            const height = chartHeight - margin.top - margin.bottom;
            
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
                
            // Group data by batch and greenhouse
            const groupedData = d3.rollup(filteredData, 
                v => d3.mean(v, d => d.phr), 
                d => d.random, // batch
                d => d.greenhouse // IoT/Traditional
            );
            
            const batches = ['R1', 'R2', 'R3'];
            const types = ['IoT', 'Traditional'];
            
            // Prepare chart data
            const chartData = batches.map(batch => {
                const values = types.map(type => {
                    const val = groupedData.get(batch) && groupedData.get(batch).get(type);
                    return {
                        type,
                        value: val || 0
                    };
                });
                return {
                    batch,
                    values
                };
            });
            
            const x0 = d3.scaleBand()
                .domain(batches)
                .range([0, width])
                .padding(0.3);
            
            const x1 = d3.scaleBand()
                .domain(types)
                .range([0, x0.bandwidth()])
                .padding(0.1);
            
            const y = d3.scaleLinear()
                .domain([0, d3.max(chartData, d => d3.max(d.values, v => v.value))])
                .range([height, 0]);
            
            
            const color = greenhouseColor;
            
            // Create bar groups and bars
            const barGroups = g.selectAll(".bar-group")
                .data(chartData)
                .enter().append("g")
                .attr("class", "bar-group")
                .attr("transform", d => `translate(${x0(d.batch)},0)`);
            
            // Create bars with growing animation
            const bars = barGroups.selectAll(".height-bar")
                .data(d => d.values)
                .enter().append("rect")
                .attr("class", "height-bar")
                .attr("x", d => x1(d.type))
                .attr("width", x1.bandwidth())
                .attr("y", height)
                .attr("height", 0)
                .attr("fill", d => color(d.type))
                .attr("stroke", "#fff")
                .attr("stroke-width", 1)
                .attr("ry", 8)
                .style("cursor", "pointer");

            // Add tooltip functionality to bars
            bars
                .on('mouseover', function(event, d) {
                    // Get the parent batch data
                    const parentData = d3.select(this.parentNode).datum();
                    const batch = parentData.batch;
                    
                    // Highlight the bar
                    d3.select(this)
                        .style('opacity', 0.8)
                        .style('stroke', '#2d5a3d')
                        .style('stroke-width', '2px');
                    
                    // Show tooltip
                    const content = `
                        <div class="tooltip-title">${d.type} Greenhouse</div>
                        <div class="tooltip-content">
                            Batch: <strong>${batch}</strong><br/>
                            Avg PHR: <strong>${d.value.toFixed(2)} cm/day</strong>
                        </div>
                    `;
                    showTooltip(event, content);
                })
                .on('mouseout', function(event, d) {
                    // Remove highlight
                    d3.select(this)
                        .style('opacity', 1)
                        .style('stroke', '#fff')
                        .style('stroke-width', '1px');
                    
                    // Hide tooltip
                    hideTooltip();
                });
                
            // Animate bars growing from bottom
            bars.transition()
                .duration(1000)
                .delay((d, i, nodes) => {
                    const parentData = d3.select(nodes[i].parentNode).datum();
                    const batchIndex = chartData.indexOf(parentData);
                    return batchIndex * 150 + i * 100;
                })
                .ease(d3.easeElasticOut.amplitude(1).period(0.4))
                .attr("y", d => y(d.value))
                .attr("height", d => height - y(d.value));
            
            // Add value labels on top of bars with fade-in animation
            const labels = barGroups.selectAll(".bar-label")
                .data(d => d.values)
                .enter().append("text")
                .attr("class", "bar-label")
                .attr("x", d => x1(d.type) + x1.bandwidth() / 2)
                .attr("y", height - 5)
                .attr("text-anchor", "middle")
                .attr("font-size", "8px")
                .attr("font-weight", "bold")
                .attr("fill", "#333")
                .style("opacity", 0)
                .text(d => d.value.toFixed(1));
                
            // Animate labels appearing
            labels.transition()
                .duration(600)
                .delay((d, i, nodes) => {
                    const parentData = d3.select(nodes[i].parentNode).datum();
                    const batchIndex = chartData.indexOf(parentData);
                    return 800 + batchIndex * 150 + i * 100;
                })
                .ease(d3.easeQuadOut)
                .attr("y", d => y(d.value) - 5)
                .style("opacity", 1);
            
            // X Axis
            g.append("g")
                .attr("class", "axis")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x0))
                .selectAll("text")
                .attr("font-size", responsiveConfig.fontSize.axis)
                .attr("font-weight", "bold");
            
            // Y Axis
            g.append("g")
                .attr("class", "axis")
                .call(d3.axisLeft(y))
                .selectAll("text")
                .attr("font-size", responsiveConfig.fontSize.axis);
            
            // Y-axis label
            g.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left + 15)
                .attr("x", 0 - (height / 2))
                .attr("text-anchor", "middle")
                .attr("font-size", responsiveConfig.fontSize.label)
                .attr("font-weight", "bold")
                .attr("fill", "#333")
                .text("Average Plant Height Rate (cm/day)");
            
            // X-axis label
            g.append("text")
                .attr("transform", `translate(${width / 2}, ${height + 45})`)
                .attr("text-anchor", "middle")
                .attr("font-size", responsiveConfig.fontSize.label)
                .attr("font-weight", "bold")
                .attr("fill", "#333")
                .text("Batch");
        }
        
        function createGrowthDynamicsChart() {
            const responsiveConfig = getResponsiveConfig();
            const chartHeight = responsiveConfig.chartHeight;

            const svg = d3.select("#growthDynamicsChart")
                .append("svg")
                .attr("width", "100%")
                .attr("height", chartHeight)
                .attr("viewBox", `0 0 300 ${chartHeight}`);

            const margin = responsiveConfig.margins;
            const width = 300 - margin.left - margin.right;
            const height = chartHeight - margin.top - margin.bottom;

            // Add title
            svg.append('text')
                .attr('x', 300 / 2)
                .attr('y', 25)
                .attr('text-anchor', 'middle')
                .attr('font-size', '18px')
                .attr('font-weight', '700')
                .attr('fill', '#2d5a3d')
                .attr('letter-spacing', '-0.3px');

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Prepare data for box plot
            const measurements = [
                { key: 'phr', label: 'PHR' },
                { key: 'achp', label: 'ACHP' },
                { key: 'arl', label: 'ARL' }
            ];
            const groups = ['IoT', 'Traditional'];  // Switched order to match legend

            // Structure: {measurement, group, values: []}
            let boxData = [];
            measurements.forEach(m => {
                groups.forEach(group => {
                    const values = filteredData.filter(d => d.greenhouse === group).map(d => d[m.key]).filter(v => !isNaN(v));
                    if (values.length > 0) {
                        boxData.push({
                            measurement: m.label,
                            group,
                            values
                        });
                    }
                });
            });

            // Compute box plot stats with outlier detection
            function boxStats(values) {
                values = values.slice().sort((a, b) => a - b);
                const q1 = d3.quantile(values, 0.25);
                const median = d3.quantile(values, 0.5);
                const q3 = d3.quantile(values, 0.75);
                const iqr = q3 - q1;
                const lowerFence = q1 - 1.5 * iqr;
                const upperFence = q3 + 1.5 * iqr;
                
                // Find actual min/max within fences
                let min = q1;
                let max = q3;
                const outliers = [];
                
                values.forEach(v => {
                    if (v >= lowerFence && v <= upperFence) {
                        min = Math.min(min, v);
                        max = Math.max(max, v);
                    } else {
                        outliers.push(v);
                    }
                });
                
                return {q1, median, q3, min, max, outliers};
            }

            // Flatten for plotting
            let plotData = [];
            boxData.forEach(d => {
                const stats = boxStats(d.values);
                plotData.push({
                    measurement: d.measurement,
                    group: d.group,
                    ...stats
                });
            });

            // X scales
            const x0 = d3.scaleBand()
                .domain(measurements.map(m => m.label))
                .range([0, width])
                .paddingInner(0.3);
            const x1 = d3.scaleBand()
                .domain(groups)
                .range([0, x0.bandwidth()])
                .padding(0.2);

            // Y scale
            const allValues = plotData.flatMap(d => [...d.outliers, d.min, d.max]);
            const y = d3.scaleLinear()
                .domain([d3.min(allValues), d3.max(allValues)])
                .nice()
                .range([height, 0]);

            const color = greenhouseColor;

            // Draw box plots with animations
            const boxGroups = g.selectAll('.box-group')
                .data(plotData)
                .enter()
                .append('g')
                .attr('transform', d => `translate(${x0(d.measurement) + x1(d.group)},0)`)
                .style('opacity', 0);
                
            // Fade in box groups
            boxGroups.transition()
                .duration(600)
                .delay((d, i) => i * 100)
                .ease(d3.easeQuadOut)
                .style('opacity', 1);
                
            boxGroups.each(function(d, i) {
                const box = d3.select(this);
                const boxWidth = x1.bandwidth();
                
                // Box (Q1 to Q3) with scale animation
                const boxRect = box.append('rect')
                    .attr('y', y(d.q3))
                    .attr('height', 0)
                    .attr('width', boxWidth)
                    .attr('fill', color(d.group))
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1)
                    .style('cursor', 'pointer');
                    
                // Add tooltip functionality to box
                boxRect
                    .on('mouseover', function(event, boxData) {
                        // Highlight the box
                        d3.select(this)
                            .style('stroke', '#000')
                            .style('stroke-width', '3px');
                        
                        // Show tooltip with box plot statistics
                        const content = `
                            <div class="tooltip-title">${boxData.measurement} - ${boxData.group}</div>
                            <div class="tooltip-content">
                                Max: <strong>${boxData.max.toFixed(2)}</strong><br/>
                                Q3: <strong>${boxData.q3.toFixed(2)}</strong><br/>
                                Median: <strong>${boxData.median.toFixed(2)}</strong><br/>
                                Q1: <strong>${boxData.q1.toFixed(2)}</strong><br/>
                                Min: <strong>${boxData.min.toFixed(2)}</strong><br/>
                                Outliers: <strong>${boxData.outliers.length}</strong>
                            </div>
                        `;
                        showTooltip(event, content);
                    })
                    .on('mouseout', function(event, boxData) {
                        // Remove highlight
                        d3.select(this)
                            .style('stroke', '#333')
                            .style('stroke-width', '1px');
                        
                        // Hide tooltip
                        hideTooltip();
                    });
                    
                boxRect.transition()
                    .duration(800)
                    .delay(200 + i * 100)
                    .ease(d3.easeBackOut)
                    .attr('height', y(d.q1) - y(d.q3));
                    
                // Median line with draw animation
                const medianLine = box.append('line')
                    .attr('x1', 0)
                    .attr('x2', 0)
                    .attr('y1', y(d.median))
                    .attr('y2', y(d.median))
                    .attr('stroke', '#333')
                    .attr('stroke-width', 2);
                    
                medianLine.transition()
                    .duration(600)
                    .delay(600 + i * 100)
                    .ease(d3.easeQuadOut)
                    .attr('x2', boxWidth);
                
                // Whisker lines with grow animation
                const whiskerBottom = box.append('line')
                    .attr('x1', boxWidth/2)
                    .attr('x2', boxWidth/2)
                    .attr('y1', y(d.q1))
                    .attr('y2', y(d.q1))
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1);
                    
                whiskerBottom.transition()
                    .duration(400)
                    .delay(800 + i * 100)
                    .ease(d3.easeQuadOut)
                    .attr('y2', y(d.min));
                    
                const whiskerTop = box.append('line')
                    .attr('x1', boxWidth/2)
                    .attr('x2', boxWidth/2)
                    .attr('y1', y(d.q3))
                    .attr('y2', y(d.q3))
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1);
                    
                whiskerTop.transition()
                    .duration(400)
                    .delay(800 + i * 100)
                    .ease(d3.easeQuadOut)
                    .attr('y2', y(d.max));
                
                // Whisker caps with fade-in
                const capBottom = box.append('line')
                    .attr('x1', boxWidth/4)
                    .attr('x2', boxWidth*3/4)
                    .attr('y1', y(d.min))
                    .attr('y2', y(d.min))
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1)
                    .style('opacity', 0);
                    
                capBottom.transition()
                    .duration(300)
                    .delay(1000 + i * 100)
                    .ease(d3.easeQuadOut)
                    .style('opacity', 1);
                    
                const capTop = box.append('line')
                    .attr('x1', boxWidth/4)
                    .attr('x2', boxWidth*3/4)
                    .attr('y1', y(d.max))
                    .attr('y2', y(d.max))
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1)
                    .style('opacity', 0);
                    
                capTop.transition()
                    .duration(300)
                    .delay(1000 + i * 100)
                    .ease(d3.easeQuadOut)
                    .style('opacity', 1);
                
                // Outliers with bounce animation
                d.outliers.forEach((outlier, outlierIndex) => {
                    const outlierCircle = box.append('circle')
                        .attr('cx', boxWidth/2)
                        .attr('cy', y(outlier))
                        .attr('r', 0)
                        .attr('fill', '#333')
                        .attr('stroke', 'none')
                        .style('cursor', 'pointer');
                        
                    // Add tooltip functionality to outliers
                    outlierCircle
                        .on('mouseover', function(event) {
                            // Highlight the outlier
                            d3.select(this)
                                .attr('r', 4)
                                .attr('fill', '#ff6b6b')
                                .attr('stroke', '#fff')
                                .attr('stroke-width', '2px');
                            
                            // Show tooltip for outlier
                            const content = `
                                <div class="tooltip-title">Outlier - ${d.measurement}</div>
                                <div class="tooltip-content">
                                    Greenhouse: <strong>${d.group}</strong><br/>
                                    Value: <strong>${outlier.toFixed(2)}</strong><br/>
                                    Status: <strong>Outlier</strong>
                                </div>
                            `;
                            showTooltip(event, content);
                        })
                        .on('mouseout', function(event) {
                            // Remove highlight
                            d3.select(this)
                                .attr('r', 2)
                                .attr('fill', '#333')
                                .attr('stroke', 'none');
                            
                            // Hide tooltip
                            hideTooltip();
                        });
                        
                    outlierCircle.transition()
                        .duration(400)
                        .delay(1200 + i * 100 + outlierIndex * 50)
                        .ease(d3.easeBounceOut)
                        .attr('r', 2);
                });
                });

            // X Axis
            g.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x0))
                .selectAll("text")
                .attr("font-size", responsiveConfig.fontSize.axis)
                .attr("font-weight", "bold")
                .attr("fill", "#333");
                
            // Y Axis
            g.append('g')
                .call(d3.axisLeft(y))
                .selectAll("text")
                .attr("font-size", responsiveConfig.fontSize.axis);
                
            // Y-axis label
            g.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left + 20)
                .attr("x", 0 - (height / 2))
                .attr("text-anchor", "middle")
                .attr("font-size", responsiveConfig.fontSize.label)
                .attr("font-weight", "bold")
                .attr("fill", "#333")
                .text("Value");
                
            // X-axis label
            g.append("text")
                .attr("transform", `translate(${width / 2}, ${height + 45})`)
                .attr("text-anchor", "middle")
                .attr("font-size", responsiveConfig.fontSize.label)
                .attr("font-weight", "bold")
                .attr("fill", "#333")
                .text("Measurement");
        }
        
        function createViolinPlotChart() {
            const responsiveConfig = getResponsiveConfig();
            const chartHeight = responsiveConfig.chartHeight;

            const svg = d3.select("#violinPlotChart")
                .append("svg")
                .attr("width", "100%")
                .attr("height", chartHeight)
                .attr("viewBox", `0 0 300 ${chartHeight}`);

            const margin = responsiveConfig.margins;
            const width = 300 - margin.left - margin.right;
            const height = chartHeight - margin.top - margin.bottom;

            // Add title
            svg.append('text')
                .attr('x', 300 / 2)
                .attr('y', 25)
                .attr('text-anchor', 'middle')
                .attr('font-size', '18px')
                .attr('font-weight', '700')
                .attr('fill', '#2d5a3d')
                .attr('letter-spacing', '-0.3px');

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Prepare data - separate by greenhouse type and category
            const categories = ['PDMVG', 'PDMRG'];
            const greenhouses = ['IoT', 'Traditional'];
            
            // Create data structure for each combination
            let violinData = [];
            categories.forEach(cat => {
                greenhouses.forEach(greenhouse => {
                    const key = cat.toLowerCase();
                    const values = filteredData
                        .filter(d => d.greenhouse === greenhouse)
                        .map(d => d[key])
                        .filter(v => !isNaN(v) && v > 0);
                    
                    if (values.length > 0) {
                        violinData.push({
                            category: cat,
                            greenhouse: greenhouse,
                            values: values,
                            label: `${cat}-${greenhouse}`
                        });
                    }
                });
            });

            // Y scale - use all values to get consistent scale
            const allValues = violinData.flatMap(d => d.values);
            const y = d3.scaleLinear()
                .domain([d3.min(allValues), d3.max(allValues)])
                .range([height, 0])
                .nice();

            // X scale for categories
            const x0 = d3.scaleBand()
                .domain(categories)
                .range([0, width])
                .padding(0.3);

            // X scale for greenhouse types within each category
            const x1 = d3.scaleBand()
                .domain(greenhouses)
                .range([0, x0.bandwidth()])
                .padding(0.1);

            // Kernel density estimator
            function kernelDensityEstimator(kernel, X) {
                return function(V) {
                    return X.map(function(x) {
                        return [x, d3.mean(V, function(v) { return kernel(x - v); })];
                    });
                };
            }
            function kernelEpanechnikov(k) {
                return function(v) {
                    return Math.abs(v /= k) <= 1 ? 0.75 * (1 - v * v) / k : 0;
                };
            }

            // Color scale for greenhouse types
            const color = greenhouseColor;

            // Draw violins
            violinData.forEach((data, i) => {
                const categoryIndex = categories.indexOf(data.category);
                const greenhouseIndex = greenhouses.indexOf(data.greenhouse);
                const xPos = x0(data.category) + x1(data.greenhouse);
                const xCenter = xPos + x1.bandwidth() / 2;
                
                const kde = kernelDensityEstimator(kernelEpanechnikov(5), y.ticks(50));
                const density = kde(data.values);
                const maxDensity = d3.max(density, d => d[1]);
                
                if (maxDensity > 0) {
                    const scale = d3.scaleLinear()
                        .range([0, x1.bandwidth() * 0.35]) // Adjust width for grouped violins
                        .domain([0, maxDensity]);
                    
                    const area = d3.area()
                        .x0(d => xCenter - scale(d[1]))
                        .x1(d => xCenter + scale(d[1]))
                        .y(d => y(d[0]))
                        .curve(d3.curveBasis);
                    
                    // Create violin with morphing animation
                    const violinPath = g.append('path')
                        .datum(density)
                        .attr('fill', color(data.greenhouse))
                        .attr('opacity', 0)
                        .attr('stroke', '#333')
                        .attr('stroke-width', 1)
                        .style('cursor', 'pointer');
                    
                    // Start from a line and morph to violin shape
                    const lineArea = d3.area()
                        .x0(xCenter)
                        .x1(xCenter)
                        .y(d => y(d[0]))
                        .curve(d3.curveBasis);
                    
                    // Add tooltip functionality to violin
                    violinPath
                        .on('mouseover', function(event) {
                            // Highlight the violin
                            d3.select(this)
                                .attr('opacity', 1)
                                .attr('stroke', '#000')
                                .attr('stroke-width', '3px');
                            
                            // Calculate distribution statistics
                            const values = data.values;
                            const mean = d3.mean(values);
                            const median = d3.median(values);
                            const min = d3.min(values);
                            const max = d3.max(values);
                            const std = d3.deviation(values);
                            
                            // Show tooltip with violin statistics
                            const content = `
                                <div class="tooltip-title">${data.category} - ${data.greenhouse}</div>
                                <div class="tooltip-content">
                                    Sample Size: <strong>${values.length}</strong><br/>
                                    Mean: <strong>${mean?.toFixed(3) || 'N/A'}</strong><br/>
                                    Median: <strong>${median?.toFixed(3) || 'N/A'}</strong><br/>
                                    Min: <strong>${min?.toFixed(3) || 'N/A'}</strong><br/>
                                    Max: <strong>${max?.toFixed(3) || 'N/A'}</strong><br/>
                                    Std Dev: <strong>${std?.toFixed(3) || 'N/A'}</strong>
                                </div>
                            `;
                            showTooltip(event, content);
                        })
                        .on('mouseout', function(event) {
                            // Remove highlight
                            d3.select(this)
                                .attr('opacity', 0.8)
                                .attr('stroke', '#333')
                                .attr('stroke-width', '1px');
                            
                            // Hide tooltip
                            hideTooltip();
                        });
                    
                    violinPath
                        .attr('d', lineArea)
                        .transition()
                        .duration(1500)
                        .delay(i * 200)
                        .ease(d3.easeElasticOut.amplitude(1).period(0.8))
                        .attr('d', area)
                        .attr('opacity', 0.8);
                }
            });

            // X Axis
            g.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x0))
                .selectAll("text")
                .attr("font-size", responsiveConfig.fontSize.axis)
                .attr("font-weight", "bold")
                .attr("fill", "#333");
                
            // Y Axis
            g.append('g')
                .call(d3.axisLeft(y))
                .selectAll("text")
                .attr("font-size", responsiveConfig.fontSize.axis)
                .attr("fill", "#333");
                
            // Y-axis label
            g.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left + 20)
                .attr("x", 0 - (height / 2))
                .attr("text-anchor", "middle")
                .attr("font-size", responsiveConfig.fontSize.label)
                .attr("font-weight", "bold")
                .attr("fill", "#333")
                .text("Dry-Matter Value");
                
            // X-axis label
            g.append("text")
                .attr("transform", `translate(${width / 2}, ${height + 45})`)
                .attr("text-anchor", "middle")
                .attr("font-size", responsiveConfig.fontSize.label)
                .attr("font-weight", "bold")
                .attr("fill", "#333")
                .text("Category");
        }
        
        function createBiomassChart() {
            const responsiveConfig = getResponsiveConfig();

            const svg = d3.select("#biomassChart")
                .append("svg")
                .attr("width", "100%")
                .attr("height", 350)
                .attr("viewBox", "0 0 550 350")
                .style("display", "block")
                .style("margin", "0 auto");
                
            const margin = { top: 40, right: 40, bottom: 80, left: 70 };
            const width = 550 - margin.left - margin.right;
            const height = 350 - margin.top - margin.bottom;
            
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
                
            // Get current filter state
            const currentFilter = getFilterValues();
            const measurements = ['AWWGV', 'ADWV'];
            
            let chartData, xDomain, xAxisLabel;
            
            // Determine chart mode based on filter
            if (currentFilter.greenhouse === 'all') {
                // Show IoT vs Traditional comparison
                const groupedData = d3.rollup(filteredData, 
                    v => ({
                        awwgv: d3.mean(v, d => d.awwgv),
                        adwv: d3.mean(v, d => d.adwv)
                    }), 
                    d => d.greenhouse
                );
                
                const greenhouses = ['IoT', 'Traditional'];
                chartData = greenhouses.map(greenhouse => {
                    const greenhouseData = groupedData.get(greenhouse);
                    const values = measurements.map(measurement => ({
                        measurement,
                        value: measurement === 'AWWGV' ? (greenhouseData?.awwgv || 0) : (greenhouseData?.adwv || 0)
                    }));
                    return {
                        category: greenhouse,
                        values
                    };
                });
                xDomain = greenhouses;
                xAxisLabel = "Greenhouse Type";
            } else {
                // Show batches for specific greenhouse type
                const batches = ['R1', 'R2', 'R3'];
                const groupedData = d3.rollup(filteredData, 
                    v => ({
                        awwgv: d3.mean(v, d => d.awwgv),
                        adwv: d3.mean(v, d => d.adwv)
                    }), 
                    d => d.random // batch
                );
                
                chartData = batches.map(batch => {
                    const batchData = groupedData.get(batch);
                    const values = measurements.map(measurement => ({
                        measurement,
                        value: measurement === 'AWWGV' ? (batchData?.awwgv || 0) : (batchData?.adwv || 0)
                    }));
                    return {
                        category: batch,
                        values
                    };
                });
                xDomain = batches;
                xAxisLabel = "Batch";
            }
            
            const x0 = d3.scaleBand()
                .domain(xDomain)
                .range([0, width])
                .padding(0.3);
                
            const x1 = d3.scaleBand()
                .domain(measurements)
                .range([0, x0.bandwidth()])
                .padding(0.1);
                
            const y = d3.scaleLinear()
                .domain([0, d3.max(chartData, d => d3.max(d.values, v => v.value))])
                .nice()
                .range([height, 0]);
                
            const color = d3.scaleOrdinal()
                .domain(measurements)
                .range(['#00B4D8', '#B47400']);
                
            // Create bar groups and bars
            const barGroups = g.selectAll(".bar-group")
                .data(chartData)
                .enter().append("g")
                .attr("class", "bar-group")
                .attr("transform", d => `translate(${x0(d.category)},0)`);
                
            // Create bars with wave animation
            const bars = barGroups.selectAll(".biomass-bar")
                .data(d => d.values)
                .enter().append("rect")
                .attr("class", "biomass-bar")
                .attr("x", d => x1(d.measurement))
                .attr("width", x1.bandwidth())
                .attr("y", height)
                .attr("height", 0)
                .attr("fill", d => color(d.measurement))
                .attr("stroke", "#fff")
                .attr("stroke-width", 1)
                .attr("ry", 10)
                .style("cursor", "pointer");
                
            // Add tooltip functionality to bars
            bars
                .on('mouseover', function(event, d) {
                    // Get the parent category data
                    const parentData = d3.select(this.parentNode).datum();
                    const category = parentData.category;
                    
                    // Highlight the bar
                    d3.select(this)
                        .style('opacity', 0.8)
                        .style('stroke', '#2d5a3d')
                        .style('stroke-width', '3px');
                    
                    // Create detailed tooltip content
                    const measurementName = d.measurement === 'AWWGV' ? 'Wet Weight' : 'Dry Weight';
                    const unit = 'g'; // grams
                    const content = `
                        <div class="tooltip-title">Vegetative Biomass - ${measurementName}</div>
                        <div class="tooltip-content">
                            ${currentFilter.greenhouse === 'all' ? 'Greenhouse' : 'Batch'}: <strong>${category}</strong><br/>
                            Measurement: <strong>${measurementName} (${d.measurement})</strong><br/>
                            Average Value: <strong>${d.value.toFixed(3)} ${unit}</strong><br/>
                            Type: <strong>Vegetative Biomass</strong>
                        </div>
                    `;
                    showTooltip(event, content);
                })
                .on('mouseout', function(event, d) {
                    // Remove highlight
                    d3.select(this)
                        .style('opacity', 1)
                        .style('stroke', '#fff')
                        .style('stroke-width', '1px');
                    
                    // Hide tooltip
                    hideTooltip();
                });

            // Animate bars with wave effect
            bars.transition()
                .duration(1200)
                .delay((d, i, nodes) => {
                    const parentData = d3.select(nodes[i].parentNode).datum();
                    const categoryIndex = chartData.indexOf(parentData);
                    return categoryIndex * 200 + i * 150;
                })
                .ease(d3.easeElasticOut.amplitude(1).period(0.6))
                .attr("y", d => y(d.value))
                .attr("height", d => height - y(d.value));

            // Add labels on top of biomass bars
            const labels = barGroups.selectAll(".bar-label")
                .data(d => d.values)
                .enter().append("text")
                .attr("class", "bar-label")
                .attr("x", d => x1(d.measurement) + x1.bandwidth() / 2)
                .attr("y", d => y(d.value) - 5)          // 5px above the bar
                .attr("text-anchor", "middle")
                .attr("font-size", "8px")
                .attr("font-weight", "bold")
                .attr("fill", "#333")
                .text(d => d.value.toFixed(3))
                .style("opacity", 0);

            // fade‐in animation to match the bars
            labels.transition()
                .duration(600)
                .delay((d,i,nodes) => {
                    const parentData = d3.select(nodes[i].parentNode).datum();
                    const categoryIndex = chartData.indexOf(parentData);
                    return categoryIndex * 200 + i * 150 + 800;
            })
            .style("opacity", 1);
                
            // X Axis
            g.append("g")
                .attr("class", "axis")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x0))
                .selectAll("text")
                .attr("font-size", responsiveConfig.fontSize.axis)
                .attr("font-weight", "bold");
                
            // Y Axis
            g.append("g")
                .attr("class", "axis")
                .call(d3.axisLeft(y))
                .selectAll("text")
                .attr("font-size", responsiveConfig.fontSize.axis);
                
            // Y-axis label
            g.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left + 20)
                .attr("x", 0 - (height / 2))
                .attr("text-anchor", "middle")
                .attr("font-size", responsiveConfig.fontSize.label)
                .attr("fill", "#333")
                .attr("font-weight", "bold")
                .text("Vegetative Biomass");
                
            // X-axis label
            g.append("text")
                .attr("transform", `translate(${width / 2}, ${height + 45})`)
                .attr("text-anchor", "middle")
                .attr("font-size", responsiveConfig.fontSize.label)
                .attr("font-weight", "bold")
                .text(xAxisLabel);
                
            // Legend positioned at bottom
            // side-aligned vertical legend for categories
            const legend = svg.append("g")
            .attr("transform", `translate(${margin.left + width}, ${margin.top})`);

            measurements.forEach((measurement, i) => {
            // color swatch
            legend.append("circle")
                .attr("cx", 6)               // half of 12px diameter
                .attr("cy", i * 20 + 6)      // stack 20px apart
                .attr("r", 6)
                .attr("fill", color(measurement))
                .attr("stroke", "#333")
                .attr("stroke-width", 1);

            // label
            legend.append("text")
                .attr("x", 18)               // swatch cx + r + padding
                .attr("y", i * 20 + 10)      // align baseline with swatch
                .text(measurement)
                .attr("font-size", "10px")
                .attr("font-weight", "bold")
                .attr("fill", "#333");
            });

        }
        
        function createScatterChart() {
            const responsiveConfig = getResponsiveConfig();
            
            const svg = d3.select("#scatterChart")
                .append("svg")
                .attr("width", "100%")
                .attr("height", 350)
                .attr("viewBox", "0 0 550 350")
                .style("display", "block")
                .style("margin", "0 auto");
                
            const margin = { top: 40, right: 40, bottom: 80, left: 70 };
            const width = 550 - margin.left - margin.right;
            const height = 350 - margin.top - margin.bottom;
            
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
                
            const x = d3.scaleLinear()
                .domain(d3.extent(filteredData, d => d.awwr))
                .range([0, width]);
                
            const y = d3.scaleLinear()
                .domain(d3.extent(filteredData, d => d.ard))
                .range([height, 0]);
                
            const color = greenhouseColor;
                
            // Create dots with staggered animation
            const dots = g.selectAll(".dot")
                .data(filteredData)
                .enter().append("circle")
                .attr("class", "dot")
                .attr("r", 0)
                .attr("cx", d => x(d.awwr))
                .attr("cy", d => y(d.ard))
                .attr("fill", d => color(d.greenhouse))
                .attr("opacity", 0);
                
            // Animate dots appearing with ripple effect
            dots.transition()
                .duration(600)
                .delay((d, i) => Math.random() * 1000)
                .ease(d3.easeElasticOut.amplitude(1).period(0.3))
                .attr("r", 1.5)
                .attr("opacity", 0.6);

            // Calculate linear regression for trendline
            const xMean = d3.mean(filteredData, d => d.awwr);
            const yMean = d3.mean(filteredData, d => d.ard);
            const slope = d3.sum(filteredData, d => (d.awwr - xMean) * (d.ard - yMean)) /
                        d3.sum(filteredData, d => Math.pow(d.awwr - xMean, 2));
            const intercept = yMean - slope * xMean;

            // Compute endpoints for the trendline
            const xVals = d3.extent(filteredData, d => d.awwr);
            const lineCoords = xVals.map(xVal => ({
                x: xVal,
                y: slope * xVal + intercept
            }));

            // Draw the trendline
            g.append("line")
            .attr("x1", x(lineCoords[0].x))
            .attr("y1", y(lineCoords[0].y))
            .attr("x2", x(lineCoords[1].x))
            .attr("y2", y(lineCoords[1].y))
            .attr("stroke", "#2a4")
            .attr("stroke-width", 1.5)
            .attr("stroke-dasharray", "4 2");  // dashed line

                
            g.append("g")
                .attr("class", "axis")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x))
                .selectAll("text")
                .attr("font-size", responsiveConfig.fontSize.axis);
                
            g.append("g")
                .attr("class", "axis")
                .call(d3.axisLeft(y))
                .selectAll("text")
                .attr("font-size", responsiveConfig.fontSize.axis);
                
            // Axis labels
            g.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left + 15)
                .attr("x", 0 - (height / 2))
                .attr("text-anchor", "middle")
                .attr("font-size", responsiveConfig.fontSize.label)
                .attr("font-weight", "bold")
                .attr("fill", "#333")
                .text("Average Root Diameter");
                
            g.append("text")
                .attr("transform", `translate(${width / 2}, ${height + 45})`)
                .attr("text-anchor", "middle")
                .attr("font-size", responsiveConfig.fontSize.label)
                .attr("font-weight", "bold")
                .attr("fill", "#333")
                .text("Average Wet Weight of Root");

            // right‐side vertical legend
            const types = ["Iot", "Traditional"];

            const legend = svg.append("g")
                .attr("transform", `translate(${margin.left + width - 50}, ${margin.top + 80})`);

            types.forEach((type, i) => {
            // color circle
            legend.append("circle")
                .attr("cx", 6)               // half of 12px swatch
                .attr("cy", i * 20 + 6)      // line i × 20px down, plus radius
                .attr("r", 6)                // 12px diameter
                .attr("fill", greenhouseColor(type))
                .attr("stroke", "#333")
                .attr("stroke-width", 1);

            // label next to it
            legend.append("text")
                .attr("x", 18)               // circle cx (6) + r (6) + 6px padding
                .attr("y", i * 20 + 10)      // cy (i*20+6) + 4px so baseline sits nicely
                .text(type)
                .attr("font-size", "10px")
                .attr("font-weight", "bold")
                .attr("fill", "#333");
            });

        }
        
        function createLeavesChart() {
            const responsiveConfig = getResponsiveConfig();
            const chartHeight = responsiveConfig.chartHeight;

            const svg = d3.select("#leavesChart")
                .append("svg")
                .attr("width", "100%")
                .attr("height", chartHeight)
                .attr("viewBox", `0 0 300 ${chartHeight}`);
                
            const margin = responsiveConfig.margins;
            const width = 300 - margin.left - margin.right;
            const height = chartHeight - margin.top - margin.bottom;
            
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
                
            // roll up by rounded leaf count and greenhouse
            const rolled = d3.rollup(
                filteredData,
                v => d3.mean(v, d => d.phr),
                d => Math.round(d.anpl),
                d => d.greenhouse
            );

            const leaves = Array.from(rolled.keys()).sort((a, b) => a - b);
            const types = ["IoT", "Traditional"];
            
            // Convert to array format for plotting
            const chartData = leaves.map(lv => ({
                leaves: lv,
                values: types.map(t => ({
                    type: t,
                    value: (rolled.get(lv).get(t) || 0)
                }))
            }));
            
            // Scales
            const x0 = d3.scaleBand()
                .domain(leaves)
                .range([0, width])
                .padding(0.3);

            const x1 = d3.scaleBand()
                .domain(types)
                .range([0, x0.bandwidth()])
                .padding(0.1);

            const y = d3.scaleLinear()
                .domain([0, d3.max(chartData, d => d3.max(d.values, v => v.value))])
                .nice()
                .range([height, 0]);
            
            const barGroups = g.selectAll(".bar-group")
                .data(chartData)
                .enter().append("g")
                .attr("transform", d => `translate(${x0(d.leaves)},0)`);

            const bars = barGroups.selectAll("rect")
                .data(d => d.values)
                .enter().append("rect")
                .attr("x", d => x1(d.type))
                .attr("width", x1.bandwidth())
                .attr("y", height)
                .attr("height", 0)
                .attr("fill", d => greenhouseColor(d.type))
                .attr("stroke", "#fff")
                .attr("stroke-width", 1)
                .attr("ry", 8)
                .style("cursor", "pointer");

            // Add tooltip functionality to bars
            bars
                .on('mouseover', function(event, d) {
                    // Get the parent leaf count data
                    const parentData = d3.select(this.parentNode).datum();
                    const leafCount = parentData.leaves;
                    
                    // Highlight the bar
                    d3.select(this)
                        .style('opacity', 0.8)
                        .style('stroke', '#2d5a3d')
                        .style('stroke-width', '2px');
                    
                    // Show tooltip
                    const content = `
                        <div class="tooltip-title">${d.type} Greenhouse</div>
                        <div class="tooltip-content">
                            Leaf Count: <strong>${leafCount}</strong><br/>
                            Avg PHR: <strong>${d.value.toFixed(2)} cm/day</strong>
                        </div>
                    `;
                    showTooltip(event, content);
                })
                .on('mouseout', function(event, d) {
                    // Remove highlight
                    d3.select(this)
                        .style('opacity', 1)
                        .style('stroke', '#fff')
                        .style('stroke-width', '1px');
                    
                    // Hide tooltip
                    hideTooltip();
                });

            bars.transition()
                .duration(1000)
                .delay((d, i, nodes) => {
                    const pg = d3.select(nodes[i].parentNode).datum();
                    return leaves.indexOf(pg.leaves) * 150 + i * 100;
                })
                .ease(d3.easeElasticOut.amplitude(1).period(0.4))
                .attr("y", d => y(d.value))
                .attr("height", d => height - y(d.value));

            // values at bars
            barGroups.selectAll(".bar-label")
                .data(d => d.values)
                .enter().append("text")
                .attr("x", d => x1(d.type) + x1.bandwidth() / 2)
                .attr("y", height - 5)
                .attr("text-anchor", "middle")
                .attr("font-size", "8px")
                .attr("font-weight", "bold")
                .style("opacity", 0)
                .text(d => d.value.toFixed(1))
            .transition()
                .duration(600)
                .delay((d, i, nodes) => {
                const pg = d3.select(nodes[i].parentNode).datum();
                return 800 + leaves.indexOf(pg.leaves) * 150 + i * 100;
                })
                .ease(d3.easeQuadOut)
                .attr("y", d => y(d.value) - 5)
                .style("opacity", 1);

            // axes
            g.append("g")
            .attr("transform", `translate(0,${height})`)
            .call(d3.axisBottom(x0))
            .selectAll("text")
                .attr("font-size", responsiveConfig.fontSize.axis)
                .attr("font-weight", "bold");

            g.append("g")
            .call(d3.axisLeft(y))
            .selectAll("text")
                .attr("font-size", responsiveConfig.fontSize.axis);

            // axis labels
            g.append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", 0 - margin.left + 15)
            .attr("x", 0 - (height / 2))
            .attr("text-anchor", "middle")
            .attr("font-size", responsiveConfig.fontSize.label)
            .attr("font-weight", "bold")
            .text("Average Plant Height Rate (cm/day)");

            g.append("text")
            .attr("transform", `translate(${width/2}, ${height + 45})`)
            .attr("text-anchor", "middle")
            .attr("font-size", responsiveConfig.fontSize.label)
            .attr("font-weight", "bold")
            .text("Average Number of Leaves (Rounded)");
        }
        
        function createRootShootChart() {
            const responsiveConfig = getResponsiveConfig();
            const svg = d3.select("#rootShootChart")
                .append("svg")
                .attr("width", "100%")
                .attr("height", 400)
                .attr("viewBox", "0 0 550 400")
                .style("display", "block")
                .style("margin", "0 auto");
                
            const margin = { top: 40, right: 40, bottom: 80, left: 70 };
            const width = 550 - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;
            
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            // Calculate root-to-shoot ratio for each data point
            // Root weight (ADWR) / Shoot weight (ADWV)
            const chartData = filteredData.map(d => ({
                greenhouse: d.greenhouse,
                ratio: d.adwr / d.adwv // Root dry weight / Shoot dry weight
            })).filter(d => !isNaN(d.ratio) && isFinite(d.ratio) && d.ratio > 0);
            
            // Group data by greenhouse type for box plot
            const groups = ['IoT', 'Traditional'];
            let boxData = [];
            groups.forEach(group => {
                const values = chartData.filter(d => d.greenhouse === group).map(d => d.ratio);
                if (values.length > 0) {
                    boxData.push({
                        group,
                        values
                    });
                }
            });
            
            // Compute box plot statistics with outlier detection
            function boxStats(values) {
                
                values = values.slice().sort((a, b) => a - b);
                const q1 = d3.quantile(values, 0.25);
                const median = d3.quantile(values, 0.5);
                const q3 = d3.quantile(values, 0.75);
                const iqr = q3 - q1;
                const lowerFence = q1 - 1.5 * iqr;
                const upperFence = q3 + 1.5 * iqr;
                
                // Find actual min/max within fences
                let min = q1;
                let max = q3;
                const outliers = [];
                
                values.forEach(v => {
                    if (v >= lowerFence && v <= upperFence) {
                        min = Math.min(min, v);
                        max = Math.max(max, v);
                    } else {
                        outliers.push(v);
                    }
                });
                
                return {q1, median, q3, min, max, outliers};
            }
            
            // Calculate statistics for each group
            let plotData = [];
            boxData.forEach(d => {
                const stats = boxStats(d.values);
                plotData.push({
                    group: d.group,
                    ...stats
                });
            });
            
            // Scales
            const x = d3.scaleBand()
                .domain(groups)
                .range([0, width])
                .padding(0.4);
                
            // Get all values including outliers for Y scale
            const allValues = plotData.flatMap(d => [...d.outliers, d.min, d.max]);
            const y = d3.scaleLinear()
                .domain([0.5, d3.max(allValues)])
                .nice()
                .range([height, 0]);
                
            const color = greenhouseColor;
                
            // Draw box plots with animations
            const boxGroups = g.selectAll('.box-group')
                .data(plotData)
                .enter()
                .append('g')
                .attr('transform', d => `translate(${x(d.group)},0)`)
                .style('opacity', 0);
                
            // Fade in box groups
            boxGroups.transition()
                .duration(600)
                .delay((d, i) => i * 200)
                .ease(d3.easeQuadOut)
                .style('opacity', 1);
                
            boxGroups.each(function(d, i) {
                const box = d3.select(this);
                const boxWidth = x.bandwidth();
                
                // Box (Q1 to Q3) with scale animation
                const boxRect = box.append('rect')
                    .attr('y', y(d.q3))
                    .attr('height', 0)
                    .attr('width', boxWidth)
                    .attr('fill', color(d.group))
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1.5)
                    .style('cursor', 'pointer');
                    
                // Add tooltip functionality to box
                boxRect
                    .on('mouseover', function(event, boxData) {
                        // Highlight the box
                        d3.select(this)
                            .style('stroke', '#000')
                            .style('stroke-width', '3px');
                        
                        // Show tooltip with box plot statistics
                        const content = `
                            <div class="tooltip-title">Root-to-Shoot Ratio - ${boxData.group}</div>
                            <div class="tooltip-content">
                                Max Ratio: <strong>${boxData.max.toFixed(3)}</strong><br/>
                                Q3 (75th %): <strong>${boxData.q3.toFixed(3)}</strong><br/>
                                Median: <strong>${boxData.median.toFixed(3)}</strong><br/>
                                Q1 (25th %): <strong>${boxData.q1.toFixed(3)}</strong><br/>
                                Min Ratio: <strong>${boxData.min.toFixed(3)}</strong><br/>
                                Outliers: <strong>${boxData.outliers.length}</strong><br/>
                                <em>Ratio = Root Dry Weight / Shoot Dry Weight</em>
                            </div>
                        `;
                        showTooltip(event, content);
                    })
                    .on('mouseout', function(event, boxData) {
                        // Remove highlight
                        d3.select(this)
                            .style('stroke', '#333')
                            .style('stroke-width', '1.5px');
                        
                        // Hide tooltip
                        hideTooltip();
                    });

                boxRect.transition()
                    .duration(800)
                    .delay(300 + i * 200)
                    .ease(d3.easeBackOut)
                    .attr('height', y(d.q1) - y(d.q3));
                    
                // Median line with draw animation
                const medianLine = box.append('line')
                    .attr('x1', 0)
                    .attr('x2', 0)
                    .attr('y1', y(d.median))
                    .attr('y2', y(d.median))
                    .attr('stroke', '#333')
                    .attr('stroke-width', 2.5);
                    
                medianLine.transition()
                    .duration(600)
                    .delay(700 + i * 200)
                    .ease(d3.easeQuadOut)
                    .attr('x2', boxWidth);
                
                // Whisker lines with grow animation
                const whiskerBottom = box.append('line')
                    .attr('x1', boxWidth/2)
                    .attr('x2', boxWidth/2)
                    .attr('y1', y(d.q1))
                    .attr('y2', y(d.q1))
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1.5);
                    
                whiskerBottom.transition()
                    .duration(400)
                    .delay(900 + i * 200)
                    .ease(d3.easeQuadOut)
                    .attr('y2', y(d.min));
                    
                const whiskerTop = box.append('line')
                    .attr('x1', boxWidth/2)
                    .attr('x2', boxWidth/2)
                    .attr('y1', y(d.q3))
                    .attr('y2', y(d.q3))
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1.5);
                    
                whiskerTop.transition()
                    .duration(400)
                    .delay(900 + i * 200)
                    .ease(d3.easeQuadOut)
                    .attr('y2', y(d.max));
                
                // Whisker caps with fade-in
                const capBottom = box.append('line')
                    .attr('x1', boxWidth/4)
                    .attr('x2', boxWidth*3/4)
                    .attr('y1', y(d.min))
                    .attr('y2', y(d.min))
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1.5)
                    .style('opacity', 0);
                    
                capBottom.transition()
                    .duration(300)
                    .delay(1100 + i * 200)
                    .ease(d3.easeQuadOut)
                    .style('opacity', 1);
                    
                const capTop = box.append('line')
                    .attr('x1', boxWidth/4)
                    .attr('x2', boxWidth*3/4)
                    .attr('y1', y(d.max))
                    .attr('y2', y(d.max))
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1.5)
                    .style('opacity', 0);
                    
                capTop.transition()
                    .duration(300)
                    .delay(1100 + i * 200)
                    .ease(d3.easeQuadOut)
                    .style('opacity', 1);
                
                // Outliers with bounce animation
                d.outliers.forEach((outlier, outlierIndex) => {
                    const outlierCircle = box.append('circle')
                        .attr('cx', boxWidth/2)
                        .attr('cy', y(outlier))
                        .attr('r', 0)
                        .attr('fill', '#333')
                        .attr('stroke', 'none')
                        .style('cursor', 'pointer');
                        
                    // Add tooltip functionality to outliers
                    outlierCircle
                        .on('mouseover', function(event) {
                            // Highlight the outlier
                            d3.select(this)
                                .attr('r', 5)
                                .attr('fill', '#ff6b6b')
                                .attr('stroke', '#fff')
                                .attr('stroke-width', '2px');
                            
                            // Show tooltip for outlier
                            const content = `
                                <div class="tooltip-title">Outlier - Root-to-Shoot Ratio</div>
                                <div class="tooltip-content">
                                    Greenhouse: <strong>${d.group}</strong><br/>
                                    Ratio Value: <strong>${outlier.toFixed(3)}</strong><br/>
                                    Status: <strong>Statistical Outlier</strong><br/>
                                    <em>Unusually high/low ratio compared to group</em>
                                </div>
                            `;
                            showTooltip(event, content);
                        })
                        .on('mouseout', function(event) {
                            // Remove highlight
                            d3.select(this)
                                .attr('r', 2.5)
                                .attr('fill', '#333')
                                .attr('stroke', 'none');
                            
                            // Hide tooltip
                            hideTooltip();
                        });
                        
                    outlierCircle.transition()
                        .duration(400)
                        .delay(1300 + i * 200 + outlierIndex * 50)
                        .ease(d3.easeBounceOut)
                        .attr('r', 2.5);
                });
                });
                
            // X Axis
            g.append("g")
                .attr("class", "axis")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x))
                .selectAll("text")
                .attr("font-size", responsiveConfig.fontSize.axis)
                .attr("font-weight", "bold");
                
            // Y Axis
            g.append("g")
                .attr("class", "axis")
                .call(d3.axisLeft(y))
                .selectAll("text")
                .attr("font-size", responsiveConfig.fontSize.axis);
                
            // Y-axis label
            g.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left + 20)
                .attr("x", 0 - (height / 2))
                .attr("text-anchor", "middle")
                .attr("font-size", responsiveConfig.fontSize.label)
                .attr("font-weight", "bold")
                .attr("fill", "#333")
                .text("Root-to-Shoot Ratio");
                
            // X-axis label  
            g.append("text")
                .attr("transform", `translate(${width / 2}, ${height + 45})`)
                .attr("text-anchor", "middle")
                .attr("font-size", responsiveConfig.fontSize.label)
                .attr("font-weight", "bold")
                .attr("fill", "#333")
                .text("Greenhouse Type");

            // right‐side vertical legend
            const types = ["IoT", "Traditional"];

            const legend = svg.append("g")
                .attr("transform", `translate(${margin.left + width - 10}, ${margin.top})`);

            types.forEach((type, i) => {
            // color circle
            legend.append("circle")
                .attr("cx", 6)               // half of 12px swatch
                .attr("cy", i * 20 + 6)      // line i × 20px down, plus radius
                .attr("r", 6)                // 12px diameter
                .attr("fill", greenhouseColor(type))
                .attr("stroke", "#333")
                .attr("stroke-width", 1);

            // label next to it
            legend.append("text")
                .attr("x", 18)               // circle cx (6) + r (6) + 6px padding
                .attr("y", i * 20 + 10)      // cy (i*20+6) + 4px so baseline sits nicely
                .text(type)
                .attr("font-size", "10px")
                .attr("font-weight", "bold")
                .attr("fill", "#333");
            });
        }
        
        // Initialize expandable insight panels
        function initializeInsightPanels() {
            const toggleButtons = document.querySelectorAll('.insights-toggle');
            
            toggleButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const content = this.nextElementSibling;
                    const icon = this.querySelector('.toggle-icon');
                    
                    // Toggle the expanded state
                    const isExpanded = content.classList.contains('expanded');
                    
                    if (isExpanded) {
                        content.classList.remove('expanded');
                        this.classList.remove('active');
                    } else {
                        content.classList.add('expanded');
                        this.classList.add('active');
                    }
                });
            });
        }
        
        // ============================================================================
        // CHART EXPANSION FUNCTIONALITY
        // ============================================================================

        /**
         * Open chart in expanded modal view
         * @param {string} chartTitle - Title for the modal
         * @param {string} chartId - ID of the chart container to clone
         * @param {Function} chartFunction - Function to recreate the chart
         */
        function openChartModal(chartTitle, chartId, chartFunction) {
            const modal = document.getElementById('chartModal');
            const modalTitle = document.getElementById('chartModalTitle');
            const modalBody = document.getElementById('chartModalBody');

            // Set title and clear body
            modalTitle.textContent = chartTitle;
            modalBody.innerHTML = '';

            // Create expanded chart container
            const expandedContainer = document.createElement('div');
            expandedContainer.id = chartId + 'Expanded';
            expandedContainer.style.width = '100%';
            expandedContainer.style.textAlign = 'center';
            modalBody.appendChild(expandedContainer);

            // Show modal
            modal.classList.add('active');
            
            // Create the expanded chart
            setTimeout(() => {
                chartFunction(chartId + 'Expanded', true); // Pass expanded flag
            }, 100);

            // Close on background click
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    closeChartModal();
                }
            });
        }

        /**
         * Close the chart modal
         */
        function closeChartModal() {
            const modal = document.getElementById('chartModal');
            const modalBody = document.getElementById('chartModalBody');
            
            modal.classList.remove('active');
            modalBody.innerHTML = '';
        }

        /**
         * Create expanded version of pie chart
         */
        function createExpandedPieChart(containerId, isExpanded = false) {
            const config = {
                width: isExpanded ? 500 : 200,
                height: isExpanded ? 400 : 180,
                radius: isExpanded ? 120 : 60,
                center: { x: isExpanded ? 250 : 100, y: isExpanded ? 200 : 90 }
            };
            
            const svg = createBaseSVG(`#${containerId}`, config.width, config.height);
            const g = svg.append("g").attr("transform", `translate(${config.center.x},${config.center.y})`);
            
            // Prepare data
            const pieData = preparePieData(filteredData);
            const { pie, arc } = createPieGenerators(config.radius);
            const colorScale = createColorScale(['Iot', 'Traditional'], [CHART_CONFIG.colors.traditional, CHART_CONFIG.colors.iot]);
            
            // animate pie slices with tooltip functionality
            createAnimatedPieSlices(g, pie(pieData), arc, colorScale);
            
            // Add labels
            createPieLabels(g, pie(pieData), arc, filteredData.length);
        }

        /**
         * Create expanded version of metric display
         */
        function createExpandedMetricDisplay(containerId, isExpanded = false) {
            const container = d3.select(`#${containerId}`);
            
            // Create larger metric circles
            const { batch } = getFilterValues();
            let subset = data;
            if (batch !== 'all') {
                subset = data.filter(d => d.random === batch);
            }

            const grouped = d3.rollup(
                subset,
                v => d3.mean(v, d => d.pdmvg),
                d => d.greenhouse
            );
            const iot = grouped.get('IoT') || 0;
            const traditional = grouped.get('Traditional') || 0;
            const total = iot + traditional;
            
            const percentages = {
                iot: total ? Math.round(iot / total * 100) : 0,
                traditional: total ? Math.round(traditional / total * 100) : 0
            };

            // Create expanded metric display
            const metricHtml = `
                <div style="display: flex; gap: 60px; align-items: center; justify-content: center; margin: 20px 0;">
                    <div style="text-align: center;">
                        <div style="
                            width: ${isExpanded ? 150 : 80}px; 
                            height: ${isExpanded ? 150 : 80}px; 
                            border-radius: 50%; 
                            display: flex; 
                            align-items: center; 
                            justify-content: center; 
                            margin: 0 auto 15px; 
                            font-size: ${isExpanded ? 24 : 16}px; 
                            font-weight: 700; 
                            color: #ffffffb7; 
                            background: linear-gradient(135deg, #8ed3e4, #0599fc);
                            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                        ">${percentages.iot}%</div>
                        <div style="font-size: ${isExpanded ? 24 : 18}px; font-weight: 700; margin-bottom: 8px; color: #2d5a3d;">
                            ${iot.toFixed(3)} g
                        </div>
                        <div style="font-size: ${isExpanded ? 16 : 12}px; color: #b1b1b1; font-weight: 500;">IoT</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="
                            width: ${isExpanded ? 150 : 80}px; 
                            height: ${isExpanded ? 150 : 80}px; 
                            border-radius: 50%; 
                            display: flex; 
                            align-items: center; 
                            justify-content: center; 
                            margin: 0 auto 15px; 
                            font-size: ${isExpanded ? 24 : 16}px; 
                            font-weight: 700; 
                            color: #ffffffb7; 
                            background: linear-gradient(135deg, #7EA25B, #384b3d);
                            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                        ">${percentages.traditional}%</div>
                        <div style="font-size: ${isExpanded ? 24 : 18}px; font-weight: 700; margin-bottom: 8px; color: #2d5a3d;">
                            ${traditional.toFixed(3)} g
                        </div>
                        <div style="font-size: ${isExpanded ? 16 : 12}px; color: #b1b1b1; font-weight: 500;">Traditional</div>
                    </div>
                </div>
            `;
            
            container.html(metricHtml);
        }

        /**
         * Create expanded dual chart (Plant Height Rate Insights)
         */
        function createExpandedDualChart(containerId, isExpanded = false) {
            const container = d3.select(`#${containerId}`);
            
            // Determine chart type based on containerId
            if (containerId === 'growthDynamicsExpanded') {
                // Growth Dynamics & Variability charts
                const dualContainer = container.append('div')
                    .style('display', 'flex')
                    .style('gap', isExpanded ? '40px' : '10px')
                    .style('justify-content', 'center')
                    .style('align-items', 'flex-start');

                // Left chart container
                const leftChart = dualContainer.append('div')
                    .style('flex', '1')
                    .style('text-align', 'center');
                
                leftChart.append('div')
                    .style('font-weight', '700')
                    .style('margin-bottom', '10px')
                    .style('color', '#2d5a3d')
                    .style('font-size', isExpanded ? '18px' : '16px')
                    .text('Growth Distribution (PHR/ACHP/ARL)');
                    
                leftChart.append('div').attr('id', containerId + 'Left');

                // Right chart container  
                const rightChart = dualContainer.append('div')
                    .style('flex', '1')
                    .style('text-align', 'center');
                    
                rightChart.append('div')
                    .style('font-weight', '700')
                    .style('margin-bottom', '10px')
                    .style('color', '#2d5a3d')
                    .style('font-size', isExpanded ? '18px' : '16px')
                    .text('Dry-Matter Violin Comparison');
                    
                rightChart.append('div').attr('id', containerId + 'Right');

                // Create the charts
                setTimeout(() => {
                    createExpandedGrowthDynamicsChart(containerId + 'Left', isExpanded);
                    createExpandedViolinPlotChart(containerId + 'Right', isExpanded);
                }, 100);
            } else {
                // Plant Height Rate Insights charts (default)
                const dualContainer = container.append('div')
                    .style('display', 'flex')
                    .style('gap', isExpanded ? '40px' : '10px')
                    .style('justify-content', 'center')
                    .style('align-items', 'flex-start');

                // Left chart container
                const leftChart = dualContainer.append('div')
                    .style('flex', '1')
                    .style('text-align', 'center');
                
                leftChart.append('div')
                    .style('font-weight', '700')
                    .style('margin-bottom', '10px')
                    .style('color', '#2d5a3d')
                    .style('font-size', isExpanded ? '18px' : '16px')
                    .text('Plant Height Rate by Batch');
                    
                leftChart.append('div').attr('id', containerId + 'Left');

                // Right chart container  
                const rightChart = dualContainer.append('div')
                    .style('flex', '1')
                    .style('text-align', 'center');
                    
                rightChart.append('div')
                    .style('font-weight', '700')
                    .style('margin-bottom', '10px')
                    .style('color', '#2d5a3d')
                    .style('font-size', isExpanded ? '18px' : '16px')
                    .text('Plant Height Rate vs Avg Number of Leaves');
                    
                rightChart.append('div').attr('id', containerId + 'Right');

                // Create the charts
                setTimeout(() => {
                    createExpandedHeightByBatchChart(containerId + 'Left', isExpanded);
                    createExpandedLeavesChart(containerId + 'Right', isExpanded);
                }, 100);
            }
        }

        /**
         * Create expanded version of Growth Dynamics chart
         */
        function createExpandedGrowthDynamicsChart(containerId, isExpanded = false) {
            const chartWidth = isExpanded ? 500 : 300;
            const chartHeight = isExpanded ? 400 : 300;
            
            const svg = d3.select(`#${containerId}`)
                .append("svg")
                .attr("width", "100%")
                .attr("height", chartHeight)
                .attr("viewBox", `0 0 ${chartWidth} ${chartHeight}`)
                .style("display", "block")
                .style("margin", "0 auto");

            const margin = { top: 40, right: 40, bottom: 80, left: 70 };
            const width = chartWidth - margin.left - margin.right;
            const height = chartHeight - margin.top - margin.bottom;

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Prepare data for box plot (same logic as original)
            const measurements = [
                { key: 'phr', label: 'PHR' },
                { key: 'achp', label: 'ACHP' },
                { key: 'arl', label: 'ARL' }
            ];
            const groups = ['IoT', 'Traditional'];

            let boxData = [];
            measurements.forEach(m => {
                groups.forEach(group => {
                    const values = filteredData.filter(d => d.greenhouse === group).map(d => d[m.key]).filter(v => !isNaN(v));
                    if (values.length > 0) {
                        boxData.push({
                            measurement: m.label,
                            group,
                            values
                        });
                    }
                });
            });

            // Box plot stats function (same as original)
            function boxStats(values) {
                values = values.slice().sort((a, b) => a - b);
                const q1 = d3.quantile(values, 0.25);
                const median = d3.quantile(values, 0.5);
                const q3 = d3.quantile(values, 0.75);
                const iqr = q3 - q1;
                const lowerFence = q1 - 1.5 * iqr;
                const upperFence = q3 + 1.5 * iqr;
                
                let min = q1;
                let max = q3;
                const outliers = [];
                
                values.forEach(v => {
                    if (v >= lowerFence && v <= upperFence) {
                        min = Math.min(min, v);
                        max = Math.max(max, v);
                    } else {
                        outliers.push(v);
                    }
                });
                
                return {q1, median, q3, min, max, outliers};
            }

            // Prepare plot data
            let plotData = [];
            boxData.forEach(d => {
                const stats = boxStats(d.values);
                plotData.push({
                    measurement: d.measurement,
                    group: d.group,
                    ...stats
                });
            });

            // Scales
            const x0 = d3.scaleBand()
                .domain(measurements.map(m => m.label))
                .range([0, width])
                .paddingInner(0.3);
            const x1 = d3.scaleBand()
                .domain(groups)
                .range([0, x0.bandwidth()])
                .padding(0.2);

            const allValues = plotData.flatMap(d => [...d.outliers, d.min, d.max]);
            const y = d3.scaleLinear()
                .domain([d3.min(allValues), d3.max(allValues)])
                .nice()
                .range([height, 0]);

            const color = greenhouseColor;

            // Draw box plots with tooltips (same logic as original)
            const boxGroups = g.selectAll('.box-group')
                .data(plotData)
                .enter()
                .append('g')
                .attr('transform', d => `translate(${x0(d.measurement) + x1(d.group)},0)`);
                
            boxGroups.each(function(d, i) {
                const box = d3.select(this);
                const boxWidth = x1.bandwidth();
                
                // Box with tooltips
                const boxRect = box.append('rect')
                    .attr('y', y(d.q3))
                    .attr('height', y(d.q1) - y(d.q3))
                    .attr('width', boxWidth)
                    .attr('fill', color(d.group))
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1)
                    .style('cursor', 'pointer')
                    .on('mouseover', function(event, boxData) {
                        d3.select(this)
                            .style('stroke', '#000')
                            .style('stroke-width', '3px');
                        
                        const content = `
                            <div class="tooltip-title">${boxData.measurement} - ${boxData.group}</div>
                            <div class="tooltip-content">
                                Max: <strong>${boxData.max.toFixed(2)}</strong><br/>
                                Q3: <strong>${boxData.q3.toFixed(2)}</strong><br/>
                                Median: <strong>${boxData.median.toFixed(2)}</strong><br/>
                                Q1: <strong>${boxData.q1.toFixed(2)}</strong><br/>
                                Min: <strong>${boxData.min.toFixed(2)}</strong><br/>
                                Outliers: <strong>${boxData.outliers.length}</strong>
                            </div>
                        `;
                        showTooltip(event, content);
                    })
                    .on('mouseout', function(event, boxData) {
                        d3.select(this)
                            .style('stroke', '#333')
                            .style('stroke-width', '1px');
                        hideTooltip();
                    });
                
                // Median line
                box.append('line')
                    .attr('x1', 0)
                    .attr('x2', boxWidth)
                    .attr('y1', y(d.median))
                    .attr('y2', y(d.median))
                    .attr('stroke', '#333')
                    .attr('stroke-width', 2);
                
                // Whiskers
                box.append('line')
                    .attr('x1', boxWidth/2)
                    .attr('x2', boxWidth/2)
                    .attr('y1', y(d.q1))
                    .attr('y2', y(d.min))
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1);
                
                box.append('line')
                    .attr('x1', boxWidth/2)
                    .attr('x2', boxWidth/2)
                    .attr('y1', y(d.q3))
                    .attr('y2', y(d.max))
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1);
                
                // Whisker caps
                box.append('line')
                    .attr('x1', boxWidth/4)
                    .attr('x2', boxWidth*3/4)
                    .attr('y1', y(d.min))
                    .attr('y2', y(d.min))
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1);
                    
                box.append('line')
                    .attr('x1', boxWidth/4)
                    .attr('x2', boxWidth*3/4)
                    .attr('y1', y(d.max))
                    .attr('y2', y(d.max))
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1);
                
                // Outliers with tooltips
                d.outliers.forEach((outlier, outlierIndex) => {
                    box.append('circle')
                        .attr('cx', boxWidth/2)
                        .attr('cy', y(outlier))
                        .attr('r', 3)
                        .attr('fill', '#333')
                        .attr('stroke', 'none')
                        .style('cursor', 'pointer')
                        .on('mouseover', function(event) {
                            d3.select(this)
                                .attr('r', 5)
                                .attr('fill', '#ff6b6b')
                                .attr('stroke', '#fff')
                                .attr('stroke-width', '2px');
                            
                            const content = `
                                <div class="tooltip-title">Outlier - ${d.measurement}</div>
                                <div class="tooltip-content">
                                    Greenhouse: <strong>${d.group}</strong><br/>
                                    Value: <strong>${outlier.toFixed(2)}</strong><br/>
                                    Status: <strong>Outlier</strong>
                                </div>
                            `;
                            showTooltip(event, content);
                        })
                        .on('mouseout', function(event) {
                            d3.select(this)
                                .attr('r', 3)
                                .attr('fill', '#333')
                                .attr('stroke', 'none');
                            hideTooltip();
                        });
                });
            });

            // Axes
            g.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x0))
                .selectAll("text")
                .attr("font-size", isExpanded ? "12px" : "10px")
                .attr("font-weight", "bold");
                
            g.append('g')
                .call(d3.axisLeft(y))
                .selectAll("text")
                .attr("font-size", isExpanded ? "10px" : "8px");

            // Labels
            g.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left + 15)
                .attr("x", 0 - (height / 2))
                .attr("text-anchor", "middle")
                .attr("font-size", isExpanded ? "14px" : "12px")
                .attr("font-weight", "bold")
                .attr("fill", "#333")
                .text("Value");
                
            g.append("text")
                .attr("transform", `translate(${width / 2}, ${height + 45})`)
                .attr("text-anchor", "middle")
                .attr("font-size", isExpanded ? "14px" : "12px")
                .attr("font-weight", "bold")
                .attr("fill", "#333")
                .text("Measurement");
        }

        /**
         * Create expanded version of Violin Plot chart
         */
        function createExpandedViolinPlotChart(containerId, isExpanded = false) {
            const chartWidth = isExpanded ? 500 : 300;
            const chartHeight = isExpanded ? 400 : 300;
            
            const svg = d3.select(`#${containerId}`)
                .append("svg")
                .attr("width", "100%")
                .attr("height", chartHeight)
                .attr("viewBox", `0 0 ${chartWidth} ${chartHeight}`)
                .style("display", "block")
                .style("margin", "0 auto");

            const margin = { top: 40, right: 40, bottom: 80, left: 70 };
            const width = chartWidth - margin.left - margin.right;
            const height = chartHeight - margin.top - margin.bottom;

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Prepare data - separate by greenhouse type and category (same as main function)
            const categories = ['PDMVG', 'PDMRG'];
            const greenhouses = ['IoT', 'Traditional'];
            
            // Create data structure for each combination
            let violinData = [];
            categories.forEach(cat => {
                greenhouses.forEach(greenhouse => {
                    const key = cat.toLowerCase();
                    const values = filteredData
                        .filter(d => d.greenhouse === greenhouse)
                        .map(d => d[key])
                        .filter(v => !isNaN(v) && v > 0);
                    
                    if (values.length > 0) {
                        violinData.push({
                            category: cat,
                            greenhouse: greenhouse,
                            values: values,
                            label: `${cat}-${greenhouse}`
                        });
                    }
                });
            });

            // Y scale - use all values to get consistent scale
            const allValues = violinData.flatMap(d => d.values);
            const y = d3.scaleLinear()
                .domain([d3.min(allValues), d3.max(allValues)])
                .range([height, 0])
                .nice();

            // X scale for categories
            const x0 = d3.scaleBand()
                .domain(categories)
                .range([0, width])
                .padding(0.3);

            // X scale for greenhouse types within each category
            const x1 = d3.scaleBand()
                .domain(greenhouses)
                .range([0, x0.bandwidth()])
                .padding(0.1);

            // Kernel density estimator (same as original)
            function kernelDensityEstimator(kernel, X) {
                return function(V) {
                    return X.map(function(x) {
                        return [x, d3.mean(V, function(v) { return kernel(x - v); })];
                    });
                };
            }
            function kernelEpanechnikov(k) {
                return function(v) {
                    return Math.abs(v /= k) <= 1 ? 0.75 * (1 - v * v) / k : 0;
                };
            }

            // Color scale for greenhouse types
            const color = greenhouseColor;

            // Draw violins with tooltips
            violinData.forEach((data, i) => {
                const categoryIndex = categories.indexOf(data.category);
                const greenhouseIndex = greenhouses.indexOf(data.greenhouse);
                const xPos = x0(data.category) + x1(data.greenhouse);
                const xCenter = xPos + x1.bandwidth() / 2;
                
                const kde = kernelDensityEstimator(kernelEpanechnikov(5), y.ticks(50));
                const density = kde(data.values);
                const maxDensity = d3.max(density, d => d[1]);
                
                if (maxDensity > 0) {
                    const scale = d3.scaleLinear()
                        .range([0, x1.bandwidth() * 0.35])
                        .domain([0, maxDensity]);
                    
                    const area = d3.area()
                        .x0(d => xCenter - scale(d[1]))
                        .x1(d => xCenter + scale(d[1]))
                        .y(d => y(d[0]))
                        .curve(d3.curveBasis);
                    
                    // Create violin with tooltips
                    const violinPath = g.append('path')
                        .datum(density)
                        .attr('fill', color(data.greenhouse))
                        .attr('opacity', 0.8)
                        .attr('stroke', '#333')
                        .attr('stroke-width', 1)
                        .attr('d', area)
                        .style('cursor', 'pointer')
                        .on('mouseover', function(event) {
                            d3.select(this)
                                .attr('opacity', 1)
                                .attr('stroke', '#000')
                                .attr('stroke-width', '3px');
                            
                            const values = data.values;
                            const mean = d3.mean(values);
                            const median = d3.median(values);
                            const min = d3.min(values);
                            const max = d3.max(values);
                            const std = d3.deviation(values);
                            
                            const content = `
                                <div class="tooltip-title">${data.category} - ${data.greenhouse}</div>
                                <div class="tooltip-content">
                                    Sample Size: <strong>${values.length}</strong><br/>
                                    Mean: <strong>${mean?.toFixed(3) || 'N/A'}</strong><br/>
                                    Median: <strong>${median?.toFixed(3) || 'N/A'}</strong><br/>
                                    Min: <strong>${min?.toFixed(3) || 'N/A'}</strong><br/>
                                    Max: <strong>${max?.toFixed(3) || 'N/A'}</strong><br/>
                                    Std Dev: <strong>${std?.toFixed(3) || 'N/A'}</strong>
                                </div>
                            `;
                            showTooltip(event, content);
                        })
                        .on('mouseout', function(event) {
                            d3.select(this)
                                .attr('opacity', 0.8)
                                .attr('stroke', '#333')
                                .attr('stroke-width', '1px');
                            hideTooltip();
                        });
                }
            });

            // Axes
            g.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x0))
                .selectAll("text")
                .attr("font-size", "12px")
                .attr("font-weight", "bold");
                
            g.append('g')
                .call(d3.axisLeft(y))
                .selectAll("text")
                .attr("font-size", "10px");

            // Labels
            g.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left + 15)
                .attr("x", 0 - (height / 2))
                .attr("text-anchor", "middle")
                .attr("font-size", isExpanded ? "14px" : "12px")
                .attr("font-weight", "bold")
                .attr("fill", "#333")
                .text("Dry-Matter Value");
                
            g.append("text")
                .attr("transform", `translate(${width / 2}, ${height + 45})`)
                .attr("text-anchor", "middle")
                .attr("font-size", isExpanded ? "14px" : "12px")
                .attr("font-weight", "bold")
                .attr("fill", "#333")
                .text("Category");
        }

        /**
         * Create expanded biomass allocation charts
         */
        function createExpandedBiomassCharts(containerId, isExpanded = false) {
            const container = d3.select(`#${containerId}`);
            
            // Create three chart sections
            const sections = [
                { id: 'biomass', title: 'Vegetative Biomass Comparison', func: createExpandedBiomassChart },
                { id: 'scatter', title: 'Root Weight vs Root Diameter', func: createExpandedScatterChart },
                { id: 'rootShoot', title: 'Root-to-Shoot Ratio by Greenhouse', func: createExpandedRootShootChart }
            ];

            sections.forEach(section => {
                const sectionDiv = container.append('div')
                    .style('margin-bottom', isExpanded ? '40px' : '20px')
                    .style('text-align', 'center');
                    
                sectionDiv.append('div')
                    .style('font-weight', 'bold')
                    .style('margin-bottom', '15px')
                    .style('color', '#2d5a3d')
                    .style('font-size', isExpanded ? '18px' : '16px')
                    .text(section.title);
                    
                sectionDiv.append('div').attr('id', containerId + section.id);
            });

            // Create the charts
            setTimeout(() => {
                createExpandedBiomassChart(containerId + 'biomass', isExpanded);
                createExpandedScatterChart(containerId + 'scatter', isExpanded);
                createExpandedRootShootChart(containerId + 'rootShoot', isExpanded);
            }, 100);
                 }

        /**
         * Create expanded version of height by batch chart
         */
        function createExpandedHeightByBatchChart(containerId, isExpanded = false) {
            const chartWidth = isExpanded ? 500 : 300;
            const chartHeight = isExpanded ? 400 : 300;
            
            const svg = d3.select(`#${containerId}`)
                .append("svg")
                .attr("width", "100%")
                .attr("height", chartHeight)
                .attr("viewBox", `0 0 ${chartWidth} ${chartHeight}`)
                .style("display", "block")
                .style("margin", "0 auto");
                
            const margin = { top: 40, right: 40, bottom: 80, left: 70 };
            const width = chartWidth - margin.left - margin.right;
            const height = chartHeight - margin.top - margin.bottom;
            
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
                
            // Group data by batch and greenhouse
            const groupedData = d3.rollup(filteredData, 
                v => d3.mean(v, d => d.phr), 
                d => d.random, // batch
                d => d.greenhouse // IoT/Traditional
            );
            
            const batches = ['R1', 'R2', 'R3'];
            const types = ['IoT', 'Traditional'];
            
            // Prepare chart data
            const chartData = batches.map(batch => {
                const values = types.map(type => {
                    const val = groupedData.get(batch) && groupedData.get(batch).get(type);
                    return {
                        type,
                        value: val || 0
                    };
                });
                return {
                    batch,
                    values
                };
            });
            
            const x0 = d3.scaleBand()
                .domain(batches)
                .range([0, width])
                .padding(0.3);
            
            const x1 = d3.scaleBand()
                .domain(types)
                .range([0, x0.bandwidth()])
                .padding(0.1);
            
            const y = d3.scaleLinear()
                .domain([0, d3.max(chartData, d => d3.max(d.values, v => v.value))])
                .range([height, 0]);
            
            const color = greenhouseColor;
            
            // Create bar groups and bars
            const barGroups = g.selectAll(".bar-group")
                .data(chartData)
                .enter().append("g")
                .attr("class", "bar-group")
                .attr("transform", d => `translate(${x0(d.batch)},0)`);
            
            // Create bars
            const bars = barGroups.selectAll(".height-bar")
                .data(d => d.values)
                .enter().append("rect")
                .attr("class", "height-bar")
                .attr("x", d => x1(d.type))
                .attr("width", x1.bandwidth())
                .attr("y", d => y(d.value))
                .attr("height", d => height - y(d.value))
                .attr("fill", d => color(d.type))
                .attr("stroke", "#fff")
                .attr("stroke-width", 1)
                .attr("ry", 8)
                .style("cursor", "pointer");

            // Add tooltip functionality to bars
            bars
                .on('mouseover', function(event, d) {
                    // Get the parent batch data
                    const parentData = d3.select(this.parentNode).datum();
                    const batch = parentData.batch;
                    
                    // Highlight the bar
                    d3.select(this)
                        .style('opacity', 0.8)
                        .style('stroke', '#2d5a3d')
                        .style('stroke-width', '2px');
                    
                    // Show tooltip
                    const content = `
                        <div class="tooltip-title">${d.type} Greenhouse</div>
                        <div class="tooltip-content">
                            Batch: <strong>${batch}</strong><br/>
                            Avg PHR: <strong>${d.value.toFixed(2)} cm/day</strong>
                        </div>
                    `;
                    showTooltip(event, content);
                })
                .on('mouseout', function(event, d) {
                    // Remove highlight
                    d3.select(this)
                        .style('opacity', 1)
                        .style('stroke', '#fff')
                        .style('stroke-width', '1px');
                    
                    // Hide tooltip
                    hideTooltip();
                });
            
            // Add value labels
            barGroups.selectAll(".bar-label")
                .data(d => d.values)
                .enter().append("text")
                .attr("class", "bar-label")
                .attr("x", d => x1(d.type) + x1.bandwidth() / 2)
                .attr("y", d => y(d.value) - 5)
                .attr("text-anchor", "middle")
                .attr("font-size", isExpanded ? "12px" : "8px")
                .attr("font-weight", "bold")
                .attr("fill", "#333")
                .text(d => d.value.toFixed(1));
            
            // X Axis
            g.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x0))
                .selectAll("text")
                .attr("font-size", isExpanded ? "12px" : "10px")
                .attr("font-weight", "bold");
            
            // Y Axis
            g.append("g")
                .call(d3.axisLeft(y))
                .selectAll("text")
                .attr("font-size", isExpanded ? "10px" : "8px");
            
            // Y-axis label
            g.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left + 15)
                .attr("x", 0 - (height / 2))
                .attr("text-anchor", "middle")
                .attr("font-size", isExpanded ? "14px" : "12px")
                .attr("font-weight", "700")
                .attr("fill", "#333")
                .text("Average Plant Height Rate (cm/day)");
            
            // X-axis label
            g.append("text")
                .attr("transform", `translate(${width / 2}, ${height + 45})`)
                .attr("text-anchor", "middle")
                .attr("font-size", isExpanded ? "14px" : "12px")
                .attr("font-weight", "700")
                .attr("fill", "#333")
                .text("Batch");
        }

        /**
         * Create expanded version of leaves chart
         */
        function createExpandedLeavesChart(containerId, isExpanded = false) {
            const chartWidth = isExpanded ? 500 : 300;
            const chartHeight = isExpanded ? 400 : 300;
            
            const svg = d3.select(`#${containerId}`)
                .append("svg")
                .attr("width", "100%")
                .attr("height", chartHeight)
                .attr("viewBox", `0 0 ${chartWidth} ${chartHeight}`)
                .style("display", "block")
                .style("margin", "0 auto");
                
            const margin = { top: 40, right: 40, bottom: 80, left: 70 };
            const width = chartWidth - margin.left - margin.right;
            const height = chartHeight - margin.top - margin.bottom;
            
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
                
            // Roll up by rounded leaf count and greenhouse
            const rolled = d3.rollup(
                filteredData,
                v => d3.mean(v, d => d.phr),
                d => Math.round(d.anpl),
                d => d.greenhouse
            );

            const leaves = Array.from(rolled.keys()).sort((a, b) => a - b);
            const types = ["IoT", "Traditional"];
            
            // Convert to array format for plotting
            const chartData = leaves.map(lv => ({
                leaves: lv,
                values: types.map(t => ({
                    type: t,
                    value: (rolled.get(lv).get(t) || 0)
                }))
            }));
            
            // Scales
            const x0 = d3.scaleBand()
                .domain(leaves)
                .range([0, width])
                .padding(0.3);

            const x1 = d3.scaleBand()
                .domain(types)
                .range([0, x0.bandwidth()])
                .padding(0.1);

            const y = d3.scaleLinear()
                .domain([0, d3.max(chartData, d => d3.max(d.values, v => v.value))])
                .nice()
                .range([height, 0]);
            
            const barGroups = g.selectAll(".bar-group")
                .data(chartData)
                .enter().append("g")
                .attr("transform", d => `translate(${x0(d.leaves)},0)`);

            const bars = barGroups.selectAll("rect")
                .data(d => d.values)
                .enter().append("rect")
                .attr("x", d => x1(d.type))
                .attr("width", x1.bandwidth())
                .attr("y", d => y(d.value))
                .attr("height", d => height - y(d.value))
                .attr("fill", d => greenhouseColor(d.type))
                .attr("stroke", "#fff")
                .attr("stroke-width", 1)
                .attr("ry", 8)
                .style("cursor", "pointer");

            // Add tooltip functionality to bars
            bars
                .on('mouseover', function(event, d) {
                    // Get the parent leaf count data
                    const parentData = d3.select(this.parentNode).datum();
                    const leafCount = parentData.leaves;
                    
                    // Highlight the bar
                    d3.select(this)
                        .style('opacity', 0.8)
                        .style('stroke', '#2d5a3d')
                        .style('stroke-width', '2px');
                    
                    // Show tooltip
                    const content = `
                        <div class="tooltip-title">${d.type} Greenhouse</div>
                        <div class="tooltip-content">
                            Leaf Count: <strong>${leafCount}</strong><br/>
                            Avg PHR: <strong>${d.value.toFixed(2)} cm/day</strong>
                        </div>
                    `;
                    showTooltip(event, content);
                })
                .on('mouseout', function(event, d) {
                    // Remove highlight
                    d3.select(this)
                        .style('opacity', 1)
                        .style('stroke', '#fff')
                        .style('stroke-width', '1px');
                    
                    // Hide tooltip
                    hideTooltip();
                });

            // Values at bars
            barGroups.selectAll(".bar-label")
                .data(d => d.values)
                .enter().append("text")
                .attr("x", d => x1(d.type) + x1.bandwidth() / 2)
                .attr("y", d => y(d.value) - 5)
                .attr("text-anchor", "middle")
                .attr("font-size", isExpanded ? "12px" : "8px")
                .attr("font-weight", "bold")
                .text(d => d.value.toFixed(1));

            // Axes
            g.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x0))
                .selectAll("text")
                .attr("font-size", isExpanded ? "12px" : "10px")
                .attr("font-weight", "bold");

            g.append("g")
                .call(d3.axisLeft(y))
                .selectAll("text")
                .attr("font-size", isExpanded ? "10px" : "8px");

            // Axis labels
            g.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left + 15)
                .attr("x", 0 - (height / 2))
                .attr("text-anchor", "middle")
                .attr("font-size", isExpanded ? "14px" : "12px")
                .attr("font-weight", "700")
                .text("Average Plant Height Rate (cm/day)");

            g.append("text")
                .attr("transform", `translate(${width/2}, ${height + 45})`)
                .attr("text-anchor", "middle")
                .attr("font-size", isExpanded ? "14px" : "12px")
                .attr("font-weight", "700")
                .text("Average Number of Leaves (Rounded)");
        }

        /**
         * Create expanded biomass chart functions
         */
        function createExpandedBiomassChart(containerId, isExpanded = false) {
            const chartWidth = isExpanded ? 700 : 550;
            const chartHeight = isExpanded ? 450 : 350;
            
            const svg = d3.select(`#${containerId}`)
                .append("svg")
                .attr("width", "100%")
                .attr("height", chartHeight)
                .attr("viewBox", `0 0 ${chartWidth} ${chartHeight}`)
                .style("display", "block")
                .style("margin", "0 auto");
                
            const margin = { top: 40, right: 40, bottom: 80, left: 70 };
            const width = chartWidth - margin.left - margin.right;
            const height = chartHeight - margin.top - margin.bottom;
            
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
                
            // Get current filter state and prepare data (same logic as original)
            const currentFilter = getFilterValues();
            const measurements = ['AWWGV', 'ADWV'];
            
            let chartData, xDomain, xAxisLabel;
            
            if (currentFilter.greenhouse === 'all') {
                const groupedData = d3.rollup(filteredData, 
                    v => ({
                        awwgv: d3.mean(v, d => d.awwgv),
                        adwv: d3.mean(v, d => d.adwv)
                    }), 
                    d => d.greenhouse
                );
                
                const greenhouses = ['IoT', 'Traditional'];
                chartData = greenhouses.map(greenhouse => {
                    const greenhouseData = groupedData.get(greenhouse);
                    const values = measurements.map(measurement => ({
                        measurement,
                        value: measurement === 'AWWGV' ? (greenhouseData?.awwgv || 0) : (greenhouseData?.adwv || 0)
                    }));
                    return {
                        category: greenhouse,
                        values
                    };
                });
                xDomain = greenhouses;
                xAxisLabel = "Greenhouse Type";
            } else {
                const batches = ['R1', 'R2', 'R3'];
                const groupedData = d3.rollup(filteredData, 
                    v => ({
                        awwgv: d3.mean(v, d => d.awwgv),
                        adwv: d3.mean(v, d => d.adwv)
                    }), 
                    d => d.random
                );
                
                chartData = batches.map(batch => {
                    const batchData = groupedData.get(batch);
                    const values = measurements.map(measurement => ({
                        measurement,
                        value: measurement === 'AWWGV' ? (batchData?.awwgv || 0) : (batchData?.adwv || 0)
                    }));
                    return {
                        category: batch,
                        values
                    };
                });
                xDomain = batches;
                xAxisLabel = "Batch";
            }
            
            const x0 = d3.scaleBand()
                .domain(xDomain)
                .range([0, width])
                .padding(0.3);
                
            const x1 = d3.scaleBand()
                .domain(measurements)
                .range([0, x0.bandwidth()])
                .padding(0.1);
                
            const y = d3.scaleLinear()
                .domain([0, d3.max(chartData, d => d3.max(d.values, v => v.value))])
                .nice()
                .range([height, 0]);
                
            const color = d3.scaleOrdinal()
                .domain(measurements)
                .range(['#00B4D8', '#B47400']);
                
            // Create bars
            const barGroups = g.selectAll(".bar-group")
                .data(chartData)
                .enter().append("g")
                .attr("class", "bar-group")
                .attr("transform", d => `translate(${x0(d.category)},0)`);
                
            const bars = barGroups.selectAll(".biomass-bar")
                .data(d => d.values)
                .enter().append("rect")
                .attr("class", "biomass-bar")
                .attr("x", d => x1(d.measurement))
                .attr("width", x1.bandwidth())
                .attr("y", d => y(d.value))
                .attr("height", d => height - y(d.value))
                .attr("fill", d => color(d.measurement))
                .attr("stroke", "#fff")
                .attr("stroke-width", 1)
                .attr("ry", 10)
                .style("cursor", "pointer");

            // Add tooltip functionality to expanded bars
            bars
                .on('mouseover', function(event, d) {
                    // Get the parent category data
                    const parentData = d3.select(this.parentNode).datum();
                    const category = parentData.category;
                    
                    // Highlight the bar
                    d3.select(this)
                        .style('opacity', 0.8)
                        .style('stroke', '#2d5a3d')
                        .style('stroke-width', '3px');
                    
                    // Create detailed tooltip content
                    const measurementName = d.measurement === 'AWWGV' ? 'Wet Weight' : 'Dry Weight';
                    const unit = 'g'; // grams
                    const content = `
                        <div class="tooltip-title">Vegetative Biomass - ${measurementName}</div>
                        <div class="tooltip-content">
                            ${currentFilter.greenhouse === 'all' ? 'Greenhouse' : 'Batch'}: <strong>${category}</strong><br/>
                            Measurement: <strong>${measurementName} (${d.measurement})</strong><br/>
                            Average Value: <strong>${d.value.toFixed(3)} ${unit}</strong><br/>
                            Type: <strong>Vegetative Biomass</strong>
                        </div>
                    `;
                    showTooltip(event, content);
                })
                .on('mouseout', function(event, d) {
                    // Remove highlight
                    d3.select(this)
                        .style('opacity', 1)
                        .style('stroke', '#fff')
                        .style('stroke-width', '1px');
                    
                    // Hide tooltip
                    hideTooltip();
                });

            // Add labels
            barGroups.selectAll(".bar-label")
                .data(d => d.values)
                .enter().append("text")
                .attr("class", "bar-label")
                .attr("x", d => x1(d.measurement) + x1.bandwidth() / 2)
                .attr("y", d => y(d.value) - 5)
                .attr("text-anchor", "middle")
                .attr("font-size", isExpanded ? "12px" : "8px")
                .attr("font-weight", "bold")
                .attr("fill", "#333")
                .text(d => d.value.toFixed(3));
                
            // Axes
            g.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x0))
                .selectAll("text")
                .attr("font-size", isExpanded ? "12px" : "10px")
                .attr("font-weight", "bold");
                
            g.append("g")
                .call(d3.axisLeft(y))
                .selectAll("text")
                .attr("font-size", isExpanded ? "10px" : "8px");
                
            // Axis labels
            g.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left + 20)
                .attr("x", 0 - (height / 2))
                .attr("text-anchor", "middle")
                .attr("font-size", isExpanded ? "14px" : "12px")
                .attr("fill", "#333")
                .attr("font-weight", "bold")
                .text("Vegetative Biomass");
                
            g.append("text")
                .attr("transform", `translate(${width / 2}, ${height + 45})`)
                .attr("text-anchor", "middle")
                .attr("font-size", isExpanded ? "14px" : "12px")
                .attr("font-weight", "bold")
                .text(xAxisLabel);
        }

        function createExpandedScatterChart(containerId, isExpanded = false) {
            const chartWidth = isExpanded ? 700 : 550;
            const chartHeight = isExpanded ? 450 : 300;
            
            const svg = d3.select(`#${containerId}`)
                .append("svg")
                .attr("width", "100%")
                .attr("height", chartHeight)
                .attr("viewBox", `0 0 ${chartWidth} ${chartHeight}`)
                .style("display", "block")
                .style("margin", "0 auto");
                
            const margin = { top: 40, right: 40, bottom: 80, left: 70 };
            const width = chartWidth - margin.left - margin.right;
            const height = chartHeight - margin.top - margin.bottom;
            
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
                
            const x = d3.scaleLinear()
                .domain(d3.extent(filteredData, d => d.awwr))
                .range([0, width]);
                
            const y = d3.scaleLinear()
                .domain(d3.extent(filteredData, d => d.ard))
                .range([height, 0]);
                
            const color = greenhouseColor;
                
            // Create dots
            g.selectAll(".dot")
                .data(filteredData)
                .enter().append("circle")
                .attr("class", "dot")
                .attr("r", isExpanded ? 3 : 1.5)
                .attr("cx", d => x(d.awwr))
                .attr("cy", d => y(d.ard))
                .attr("fill", d => color(d.greenhouse))
                .attr("opacity", 0.6);

            // Calculate and draw trendline
            const xMean = d3.mean(filteredData, d => d.awwr);
            const yMean = d3.mean(filteredData, d => d.ard);
            const slope = d3.sum(filteredData, d => (d.awwr - xMean) * (d.ard - yMean)) /
                        d3.sum(filteredData, d => Math.pow(d.awwr - xMean, 2));
            const intercept = yMean - slope * xMean;

            const xVals = d3.extent(filteredData, d => d.awwr);
            const lineCoords = xVals.map(xVal => ({
                x: xVal,
                y: slope * xVal + intercept
            }));

            g.append("line")
                .attr("x1", x(lineCoords[0].x))
                .attr("y1", y(lineCoords[0].y))
                .attr("x2", x(lineCoords[1].x))
                .attr("y2", y(lineCoords[1].y))
                .attr("stroke", "#2a4")
                .attr("stroke-width", 1.5)
                .attr("stroke-dasharray", "4 2");
                
            // Axes
            g.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x))
                .selectAll("text")
                .attr("font-size", isExpanded ? "12px" : "10px");
                
            g.append("g")
                .call(d3.axisLeft(y))
                .selectAll("text")
                .attr("font-size", isExpanded ? "10px" : "8px");
                
            // Axis labels
            g.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left + 15)
                .attr("x", 0 - (height / 2))
                .attr("text-anchor", "middle")
                .attr("font-size", isExpanded ? "14px" : "12px")
                .attr("font-weight", "700")
                .attr("fill", "#333")
                .text("Average Root Diameter");
                
            g.append("text")
                .attr("transform", `translate(${width / 2}, ${height + 45})`)
                .attr("text-anchor", "middle")
                .attr("font-size", isExpanded ? "14px" : "12px")
                .attr("font-weight", "700")
                .attr("fill", "#333")
                .text("Average Wet Weight of Root");
        }

        function createExpandedRootShootChart(containerId, isExpanded = false) {
            const chartWidth = isExpanded ? 700 : 550;
            const chartHeight = isExpanded ? 500 : 400;
            
            const svg = d3.select(`#${containerId}`)
                .append("svg")
                .attr("width", "100%")
                .attr("height", chartHeight)
                .attr("viewBox", `0 0 ${chartWidth} ${chartHeight}`)
                .style("display", "block")
                .style("margin", "0 auto");
                
            const margin = { top: 40, right: 40, bottom: 80, left: 70 };
            const width = chartWidth - margin.left - margin.right;
            const height = chartHeight - margin.top - margin.bottom;
            
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            // Calculate root-to-shoot ratio for each data point
            const chartData = filteredData.map(d => ({
                greenhouse: d.greenhouse,
                ratio: d.adwr / d.adwv
            })).filter(d => !isNaN(d.ratio) && isFinite(d.ratio) && d.ratio > 0);
            
            // Group data by greenhouse type for box plot
            const groups = ['IoT', 'Traditional'];
            let boxData = [];
            groups.forEach(group => {
                const values = chartData.filter(d => d.greenhouse === group).map(d => d.ratio);
                if (values.length > 0) {
                    boxData.push({
                        group,
                        values
                    });
                }
            });
            
            // Compute box plot statistics
            function boxStats(values) {
                values = values.slice().sort((a, b) => a - b);
                const q1 = d3.quantile(values, 0.25);
                const median = d3.quantile(values, 0.5);
                const q3 = d3.quantile(values, 0.75);
                const iqr = q3 - q1;
                const lowerFence = q1 - 1.5 * iqr;
                const upperFence = q3 + 1.5 * iqr;
                
                let min = q1;
                let max = q3;
                const outliers = [];
                
                values.forEach(v => {
                    if (v >= lowerFence && v <= upperFence) {
                        min = Math.min(min, v);
                        max = Math.max(max, v);
                    } else {
                        outliers.push(v);
                    }
                });
                
                return {q1, median, q3, min, max, outliers};
            }
            
            // Calculate statistics for each group
            let plotData = [];
            boxData.forEach(d => {
                const stats = boxStats(d.values);
                plotData.push({
                    group: d.group,
                    ...stats
                });
            });
            
            // Scales
            const x = d3.scaleBand()
                .domain(groups)
                .range([0, width])
                .padding(0.4);
                
            const allValues = plotData.flatMap(d => [...d.outliers, d.min, d.max]);
            const y = d3.scaleLinear()
                .domain([0.5, d3.max(allValues)])
                .nice()
                .range([height, 0]);
                
            const color = greenhouseColor;
                
            // Draw box plots with tooltips
            plotData.forEach((d, i) => {
                const boxWidth = x.bandwidth();
                const xPos = x(d.group);
                
                // Box (Q1 to Q3) with tooltips
                g.append('rect')
                    .attr('x', xPos)
                    .attr('y', y(d.q3))
                    .attr('width', boxWidth)
                    .attr('height', y(d.q1) - y(d.q3))
                    .attr('fill', color(d.group))
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1.5)
                    .style('cursor', 'pointer')
                    .on('mouseover', function(event) {
                        // Highlight the box
                        d3.select(this)
                            .style('stroke', '#000')
                            .style('stroke-width', '3px');
                        
                        // Show tooltip with box plot statistics
                        const content = `
                            <div class="tooltip-title">Root-to-Shoot Ratio - ${d.group}</div>
                            <div class="tooltip-content">
                                Max Ratio: <strong>${d.max.toFixed(3)}</strong><br/>
                                Q3 (75th %): <strong>${d.q3.toFixed(3)}</strong><br/>
                                Median: <strong>${d.median.toFixed(3)}</strong><br/>
                                Q1 (25th %): <strong>${d.q1.toFixed(3)}</strong><br/>
                                Min Ratio: <strong>${d.min.toFixed(3)}</strong><br/>
                                Outliers: <strong>${d.outliers.length}</strong><br/>
                                <em>Ratio = Root Dry Weight / Shoot Dry Weight</em>
                            </div>
                        `;
                        showTooltip(event, content);
                    })
                    .on('mouseout', function(event) {
                        // Remove highlight
                        d3.select(this)
                            .style('stroke', '#333')
                            .style('stroke-width', '1.5px');
                        
                        // Hide tooltip
                        hideTooltip();
                    });
                    
                // Median line
                g.append('line')
                    .attr('x1', xPos)
                    .attr('x2', xPos + boxWidth)
                    .attr('y1', y(d.median))
                    .attr('y2', y(d.median))
                    .attr('stroke', '#333')
                    .attr('stroke-width', 2.5);
                
                // Whiskers
                g.append('line')
                    .attr('x1', xPos + boxWidth/2)
                    .attr('x2', xPos + boxWidth/2)
                    .attr('y1', y(d.q1))
                    .attr('y2', y(d.min))
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1.5);
                    
                g.append('line')
                    .attr('x1', xPos + boxWidth/2)
                    .attr('x2', xPos + boxWidth/2)
                    .attr('y1', y(d.q3))
                    .attr('y2', y(d.max))
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1.5);
                
                // Whisker caps
                g.append('line')
                    .attr('x1', xPos + boxWidth/4)
                    .attr('x2', xPos + boxWidth*3/4)
                    .attr('y1', y(d.min))
                    .attr('y2', y(d.min))
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1.5);
                    
                g.append('line')
                    .attr('x1', xPos + boxWidth/4)
                    .attr('x2', xPos + boxWidth*3/4)
                    .attr('y1', y(d.max))
                    .attr('y2', y(d.max))
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1.5);
                
                // Outliers with tooltips
                d.outliers.forEach((outlier) => {
                    g.append('circle')
                        .attr('cx', xPos + boxWidth/2)
                        .attr('cy', y(outlier))
                        .attr('r', isExpanded ? 3 : 2.5)
                        .attr('fill', '#333')
                        .attr('stroke', 'none')
                        .style('cursor', 'pointer')
                        .on('mouseover', function(event) {
                            // Highlight the outlier
                            d3.select(this)
                                .attr('r', isExpanded ? 6 : 5)
                                .attr('fill', '#ff6b6b')
                                .attr('stroke', '#fff')
                                .attr('stroke-width', '2px');
                            
                            // Show tooltip for outlier
                            const content = `
                                <div class="tooltip-title">Outlier - Root-to-Shoot Ratio</div>
                                <div class="tooltip-content">
                                    Greenhouse: <strong>${d.group}</strong><br/>
                                    Ratio Value: <strong>${outlier.toFixed(3)}</strong><br/>
                                    Status: <strong>Statistical Outlier</strong><br/>
                                    <em>Unusually high/low ratio compared to group</em>
                                </div>
                            `;
                            showTooltip(event, content);
                        })
                        .on('mouseout', function(event) {
                            // Remove highlight
                            d3.select(this)
                                .attr('r', isExpanded ? 3 : 2.5)
                                .attr('fill', '#333')
                                .attr('stroke', 'none');
                            
                            // Hide tooltip
                            hideTooltip();
                        });
                });
            });
                
            // Axes
            g.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x))
                .selectAll("text")
                .attr("font-size", isExpanded ? "12px" : "10px")
                .attr("font-weight", "bold");
                
            g.append("g")
                .call(d3.axisLeft(y))
                .selectAll("text")
                .attr("font-size", isExpanded ? "10px" : "8px");
                
            // Axis labels
            g.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left + 20)
                .attr("x", 0 - (height / 2))
                .attr("text-anchor", "middle")
                .attr("font-size", isExpanded ? "14px" : "12px")
                .attr("font-weight", "700")
                .attr("fill", "#333")
                .text("Root-to-Shoot Ratio");
                
            g.append("text")
                .attr("transform", `translate(${width / 2}, ${height + 45})`)
                .attr("text-anchor", "middle")
                .attr("font-size", isExpanded ? "14px" : "12px")
                .attr("font-weight", "bold")
                .attr("fill", "#333")
                .text("Greenhouse Type");
        }

        // ============================================================================
        // INITIALIZATION
        // ============================================================================
        
        /**
         * Handle window resize for responsive charts
         */
        function handleResize() {
            // Debounce resize events
            clearTimeout(window.resizeTimer);
            window.resizeTimer = setTimeout(() => {
                clearAllCharts();
                createAllVisualizations();
            }, 250);
        }

        /**
         * Initialize responsive features
         */
        function initializeResponsive() {
            // Add touch-friendly interactions for mobile
            if ('ontouchstart' in window) {
                document.body.classList.add('touch-device');
                
                // Add touch styles
                const style = document.createElement('style');
                style.textContent = `
                    .touch-device .filter-dropdown {
                        min-height: 44px; /* Apple's recommended touch target size */
                    }
                    
                    .touch-device .insights-toggle {
                        min-height: 44px;
                    }
                    
                    .touch-device .dot {
                        min-width: 44px;
                        min-height: 44px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }
                `;
                document.head.appendChild(style);
            }

            // Handle orientation change on mobile devices
            window.addEventListener('orientationchange', () => {
                setTimeout(handleResize, 100);
            });

            // Handle window resize
            window.addEventListener('resize', handleResize);
        }

        /**
         * Initialize the entire dashboard
         */
        function initializeDashboard() {
            waitForD3(() => {
                loadData();
                initializeResponsive();
            });
        }
        
        // Initialize dashboard when page loads
        document.addEventListener('DOMContentLoaded', initializeDashboard);
        
        // ============================================================================
        // LEGACY EVENT LISTENERS (to be removed)
        // ============================================================================
        
        // Note: This is legacy code that will be replaced by setupEventListeners()
        document.getElementById('greenhouseFilter')?.addEventListener('change', function() {
            console.log('Greenhouse filter changed:', this.value);
        });
        
        document.getElementById('batchFilter').addEventListener('change', function() {
            // Filter functionality can be implemented here
            console.log('Batch filter changed:', this.value);
        });
    </script>
</body>
</html> 
